<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程（一）]]></title>
    <url>%2Fmyblog%2Fpost%2F9fbdefba.html</url>
    <content type="text"><![CDATA[1、进程和线程1.1 进程进程是操作系统运行程序的基本单位，是一次程序的执行。简单来说一个进程就是一个运行中的程序。 1.2 线程线程可以认为是在进程中独立运行的子任务。一个进程会有多个线程。 1.3 进程和线程区别进程和线程最大区别就是，各个进程是独立的，而线程却不一定，同一进程中的线程可能是相互影响的。进程属于操作心痛范围的，同一时间会运行多个程序，每个进程上的又会有多个线程在执行同个或不同的任务。 1.4 多线程多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。 2、使用多线程在Java的JDK开发包中，实现多线程主要有两种，一种是继承Thread类，另一种是实现Runnable接口。其实还有很多事项多线程方法，例如：使用ExecutorService、Callable、Future实现由返回结果的多线程，这是通过线程池创建的任务，可以参考《一篇搞懂线程池》。现在我们只来具体来讲一下前两种方法的使用。 2.1 继承Thread类在创建多线程前，我们先来看一下Thread的类结构图： 可以看出Thread实现了Runnable接口，其实Runnable和Thread的区别就在于继承Thread创建多线程不支持多继承，为了多继承完全可以使用Runnable替换，两者创建的线程本质上没有区别。@FunctionalInterface是Java8的函数式接口，方便lambda表达式使用。 我们创建一个Mythread.java继承Thread，重写run方法： 1234567891011121314151617package main.java.com.xiaosen.Mythread;/** * @author xiaosen * @date 2019/2/24 10:36 * @description */public class MyThread extends Thread&#123; @Override public void run() &#123; super.run(); System.out.println("this is MyThread"); &#125;&#125; 运行类的代码如下： 12345678910111213import main.java.com.xiaosen.Mythread.MyThread;public class Main &#123; public static void main(String[] args) &#123; // 继承Thread MyThread myThread = new MyThread(); myThread.start(); // lambda表达式的使用 new Thread(() -&gt; System.out.println("this is lambda thread")).start(); System.out.println("Hello World!"); &#125;&#125; 运行结果如下： 123this is MyThreadHello World!this is lambda thread 这里一低昂要注意myThread调用的是start()方法，如果调用mythread.run()那么就是单纯的方法调用，而不是创建线程去执行。关于lambda表达式只给出使用方法，暂不做介绍。 从运行结果可以看见”Hello World!”的输出在两个线程中间，说明使用多线程和代码的顺序无关。CPU会以随机的时间来调用线程中的run方法。 2.3 实现Runnable接口创建MyRunnable实现Runnable接口： 12345678910111213package main.java.com.xiaosen.myrunnable;/** * @author xiaosen * @date 2019/2/24 11:20 * @description */public class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println("run MyRunnable"); &#125;&#125; main方法使用： 12345// 实现Runnable MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); System.out.println("Hello World!"); 输出内容： 12Hello World!run MyRunnable 使用Runnable方法需要用到Thread的构造方法。 3、线程安全自定义的实例变量有共享和不共享之分，在多线程交互的时候很重要。 3.1 不共享数据创建一个类继承Thread： 123456789101112131415161718192021222324252627public class NotShareThread extends Thread&#123; private int count = 5; public NotShareThread(String name)&#123; super(); this.setName(name); &#125; @Override public void run() &#123; super.run(); while (count&gt;0)&#123; count--; System.out.println("线程" + this.currentThread().getName() + ":count=" + count); &#125; &#125;&#125; public static void main(String[] args)&#123; NotShareThread notShareThread1 = new NotShareThread("A"); NotShareThread notShareThread2 = new NotShareThread("B"); NotShareThread notShareThread3 = new NotShareThread("C"); notShareThread1.start(); notShareThread2.start(); notShareThread3.start(); &#125; 执行结果： 123456789101112131415线程A:count=4线程B:count=4线程C:count=4线程B:count=3线程A:count=3线程A:count=2线程A:count=1线程B:count=2线程C:count=3线程B:count=1线程A:count=0线程B:count=0线程C:count=2线程C:count=1线程C:count=0 从输出结果可以看到每一个线程都有各自的count变量，彼此变量不共享。 3.2 共享数据共享数据就是多个线程同时访问同一个变量，比如买火车票，多个线程同时操作剩余票数。 3.2.1 线程不安全123456789101112131415161718192021222324public class ShareThread extends Thread &#123; private int count = 5; @Override public void run() &#123; super.run(); count--; System.out.println("线程" + this.currentThread().getName() + ":count=" + count); &#125; public static void main(String[] args)&#123; ShareThread shareThread = new ShareThread(); Thread a = new Thread(shareThread, "A"); Thread b = new Thread(shareThread, "B"); Thread c = new Thread(shareThread, "C"); Thread d = new Thread(shareThread, "D"); Thread e = new Thread(shareThread, "E"); a.start(); b.start(); c.start(); d.start(); e.start(); &#125;&#125; 输出： 12345线程B:count=2线程E:count=0线程D:count=1线程C:count=2线程A:count=2 可以发现A，B，C三个线程的值都是2，产生非线程安全情况，我们应该避免这种情况发生。这是因为在执行i–操作分以下几步： 获取原有i值； 计算i-1； 堆i赋值。 在这三步中，如果有多线程同时访问，就会出现线程不安全情况。 3.2.2 线程安全我们来看看线程安全的代码： 123456789@Override public void run() &#123; super.run(); synchronized (ShareThread.class)&#123; count--; System.out.println("线程" + this.currentThread().getName() + ":count=" + count); &#125; &#125; 我们加上synchronized代码块加锁，那么只有拿到所锁的线程才可以执行代码块的内容，没拿到则不断尝试获取锁，知道拿到为止。 代码Github 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（五）——等待通知]]></title>
    <url>%2Fmyblog%2Fpost%2Ff5edfef8.html</url>
    <content type="text"><![CDATA[等待通知机制的实现方法wait()的作用是使当前线程进行等待，wait()方法是Object类的方法，该方法用来将当前线程放到“预执行队列”，并在wait()所在的代码处停止执行，直到接到通知或中断为止。只能在同步方法或同步快中使用wait()方法，执行wait()后，当前线程释放锁。 方法notify()也要在同步方法或同步快中调用，在调用前也必须获得该对象的的对象级别锁。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机选出一个wait状态的线程，对其发出notify通知，使他等待获取对象锁。 在执行notify()后当前线程不会马上释放锁，会在线程退出synchronized代码块才会释放锁，呈wait状态的线程才可以获取锁。当第一个获取对象锁的wait线程运行结束释放锁后，如果该对象没有再次notify，其他wait状态的线程依然会阻塞wait状态，直到这个对象发出notify或notifyAll。 1234567891011121314151617181920public class MyWait &#123; private final Object lock; MyWait(Object lock)&#123; this.lock=lock; &#125; public void waitTest()&#123; try &#123; synchronized (lock)&#123; System.out.println("开始 wait time = " + System.currentTimeMillis()); lock.wait(); System.out.println("结束 wait time = " + System.currentTimeMillis()); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516public class MyNotify &#123; private final Object lock; MyNotify(Object lock)&#123; this.lock=lock; &#125; public void notifyTest()&#123; synchronized (lock)&#123; System.out.println("开始 notify time = " + System.currentTimeMillis()); lock.notify(); System.out.println("结束 notify time = " + System.currentTimeMillis()); &#125; &#125;&#125; 123456789101112131415public class Main &#123; public static void main(String[] args)&#123; try &#123; Object lock = new Object(); MyWait myWait = new MyWait(lock); new Thread(() -&gt; myWait.waitTest()).start(); Thread.sleep(3000); MyNotify myNotify = new MyNotify(lock); new Thread(() -&gt; myNotify.notifyTest()).start(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 1234开始 wait time = 1552812964325开始 notify time = 1552812967328结束 notify time = 1552812967328结束 wait time = 1552812967328 从输出内容可以看出3秒后执行notify方法，并在notify方法执行结束后才执行wait后的方法。 相关方法 wait() ：使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。 wait(long)：超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回。 notify()：随机唤醒等待队列中等待同一共享资源的 “一个线程”，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知“一个线程”。 notifyAll()：使所有正在等待队列中等待同一共享资源的 “全部线程” 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现。 线程的基本状态 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 本节代码GitHub 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（四）——volatile关键字]]></title>
    <url>%2Fmyblog%2Fpost%2Fd1dc8d2.html</url>
    <content type="text"><![CDATA[volatile关键字当用volatile关键字声明变量的时候，就等于告诉虚拟机，这个变量极有可能被某些程序或者线程修改，为了保证比那辆被修改后应用程序范围内的所有线程可以看到这个改动，虚拟机必须采用一些方法保证这个变量的可见性。 volatile与死循环1234567891011121314151617181920212223242526272829public class PrintString &#123; private boolean isContinue = true; public boolean isContinue() &#123; return isContinue; &#125; public void setContinue(boolean aContinue) &#123; this.isContinue = aContinue; &#125; public void printStringFunc()&#123; try &#123; while (isContinue)&#123; System.out.println(&quot;run printStringFunc threadName=&quot; + Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; PrintString printString = new PrintString(); printString.printStringFunc(); System.out.println(&quot;stop printStringFunc stopThread=&quot; + Thread.currentThread().getName()); printString.setContinue(false); &#125;&#125; 123456789run printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=mainrun printStringFunc threadName=main... 上面的代码执行后会一直运行无法停下来，下面来看看解决方法。 1234567891011121314151617181920212223242526272829303132333435363738public class PringStringThread &#123; private boolean isContinue = true; public boolean isContinue() &#123; return isContinue; &#125; public void setContinue(boolean aContinue) &#123; this.isContinue = aContinue; &#125; public void printStringFunc()&#123; try &#123; while (isContinue)&#123; System.out.println("run printStringFunc threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;public static void main(String[] args)&#123; PringStringThread pringStringThread = new PringStringThread(); new Thread(() -&gt; pringStringThread.printStringFunc()).start(); try &#123; Thread.sleep(2000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; pringStringThread.setContinue(false); &#125; 1234run printStringFunc threadName=Thread-0run printStringFunc threadName=Thread-0Process finished with exit code 0 可以发现线程退出循环了。 volatile关键字与synchronized比较 volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在jdk6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字还是更多一些。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞。 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。 本节代码Github 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（三）——synchronized关键字（下）]]></title>
    <url>%2Fmyblog%2Fpost%2F5f7e4115.html</url>
    <content type="text"><![CDATA[在前两节的《Java多线程学习（一）——多线程基础》和《Java多线程学习（二）——Thread类的方法介绍》中我们接触了线程安全和非线程安全的概念，这节就来学习一下synchronized关键字的使用。 1、变量的线程安全性“非线程安全”问题存在于“实例变量中”，如果是方法内部私有的变量，则不存在“非线程安全”的问题。如果两个线程同时操作对象中的实例变量，会出现非线程安全的问题，解决方法是在方法上添加添加synchronized关键字控制同步。 2、多个对象多个锁先看代码： 123456789101112131415161718192021public class HasSelfPrivateNum &#123; // 创建被同步关键字修饰的方法 private int num = 0; synchronized public void add(String name)&#123; try &#123; if ("a".equals(name))&#123; num = 100; System.out.println("a set over"); Thread.sleep(2000); &#125;else &#123; num = 200; System.out.println("b set over"); &#125; System.out.println(name + " num = " + num); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516public class ThreadA extends Thread &#123;// 创建线程，构造器传参为上面方法的对象 private HasSelfPrivateNum hasSelfPrivateNum; public ThreadA(String name, HasSelfPrivateNum hasSelfPrivateNum)&#123; super(); this.hasSelfPrivateNum = hasSelfPrivateNum; this.setName(name); &#125; @Override public void run() &#123; super.run(); hasSelfPrivateNum.add(this.getName()); &#125;&#125; 1234567891011121314// main方法和输出 public static void main(String[] args)&#123; HasSelfPrivateNum hasSelfPrivateNum = new HasSelfPrivateNum(); HasSelfPrivateNum hasSelfPrivateNum1 = new HasSelfPrivateNum(); ThreadA threadA = new ThreadA("a", hasSelfPrivateNum); ThreadA threadA1 = new ThreadA("b", hasSelfPrivateNum1); threadA.start(); threadA1.start(); &#125;b set overa set overb num = 200a num = 100 由于本实例创建了两个HasSelfPrivateNum对象，所以就会产生两个锁，所以运行的结果是异步的。 synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。所以在上面的实例中，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。但是如果多个线程访问多个对象，JVM会创建多个锁。 将main方向修改一下： 12345678910111213public static void main(String[] args)&#123; HasSelfPrivateNum hasSelfPrivateNum = new HasSelfPrivateNum(); //HasSelfPrivateNum hasSelfPrivateNum1 = new HasSelfPrivateNum(); ThreadA threadA = new ThreadA("a", hasSelfPrivateNum); ThreadA threadA1 = new ThreadA("b", hasSelfPrivateNum); threadA.start(); threadA1.start(); &#125;----a set overa num = 100b set overb num = 200 可以看到threadA和threadA1拿到的是一个对象的锁，所以是顺序输出的。 3、synchronized方法与所对象通过上面我们知道synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。如果多个线程访问的是多个对象则不一定，因为多个对象会产生多个锁。 如果多个线程访问的是同一个对象中的未被synchronized关键字修饰的方法，线程会异步调用未被修饰的方法。 4、脏读在赋值的时候进行了同步，但在取值的时候可能会出现一些意想不到的意外，这种情况就是脏读。发生脏读的情况是在读取实例变量的时候，此值已经被其他线程修改。 1234567891011121314151617181920public class DirtyReadTest &#123; // 创建同步修改数据方法，非同步取数据方法 public String username = "A"; public String password = "AA"; synchronized public void setValue(String username, String password)&#123; try &#123; this.username = username; Thread.sleep(5000); this.password = password; System.out.println("setValue method: username = " + username + " password = " + password); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void getValue()&#123; System.out.println("getValue method: username = " + username + " password = " + password); &#125;&#125; 12345678910111213public class ThreadTest extends Thread &#123; private DirtyReadTest dirtyReadTest; public ThreadTest(DirtyReadTest dirtyReadTest)&#123; super(); this.dirtyReadTest=dirtyReadTest; &#125; @Override public void run() &#123; super.run(); dirtyReadTest.setValue("B", "BB"); &#125;&#125; 输出： 123456789public static void main(String[] args) throws Exception&#123; DirtyReadTest dirtyReadTest = new DirtyReadTest(); ThreadTest threadTest = new ThreadTest(dirtyReadTest); threadTest.start(); Thread.sleep(200); dirtyReadTest.getValue(); &#125;getValue method: username = B password = AAsetValue method: username = B password = BB 解决方法是在getValue方法上加上synchronized关键字。 当线程1调用一个对象的synchronized方法A时候，线程1就会获取该对象的锁，这是线程2是无法获取该对象的被synchronized修饰的任何方法，但是可以访问未被synchronized修饰的方法。 5、synchronized锁重入在使用synchronized时，当一个线程得到一个对象的锁后，没有释放，再次请求该对象的锁是可以再次获取到的。一个对象中的synchronized修饰的方法可以访问该对象中其他被synchronized修饰的方法，如果不可重入锁会造成死锁。 测试方法： 12345678910111213141516public class Service &#123; synchronized public void service1()&#123; System.out.println("service1"); service2(); &#125; synchronized public void service2()&#123; System.out.println("service2"); service3(); &#125; synchronized public void service3()&#123; System.out.println("service3"); &#125;&#125; 12345678public class ThreadTest extends Thread &#123; @Override public void run() &#123; super.run(); Service service = new Service(); service.service1(); &#125;&#125; 12345678public static void main(String[] args)&#123; ThreadTest threadTest = new ThreadTest(); threadTest.start(); &#125;service1service2service3 可重入锁也支持在父子类继承的环境中，子类可以通过可重入锁调用父类的同步方法。这里不再写代码了，可以自行写一写。 6、出现异常，所自动释放当一个线程执行的代码出现异常时，其所有的锁会自动释放。 7、同步不具有继承性如果父类有一个带synchronized关键字的方法，子类继承并重写了这个方法。 但是同步不能继承，所以还是需要在子类方法中添加synchronized关键字。 本节代码的GitHub。 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（二）]]></title>
    <url>%2Fmyblog%2Fpost%2Fafab0362.html</url>
    <content type="text"><![CDATA[Thread类的一些方法介绍1、currentThread()方法currentThread()方法可以返回代码被那个线程调用的信息。 测试方法如下： 12345678910111213141516171819202122232425public class MyThread extends Thread&#123; public MyThread()&#123; super(); &#125; public MyThread(String name)&#123; super(); this.setName(name); System.out.println("构造器中线程名字:" + Thread.currentThread().getName()); &#125; @Override public void run() &#123; super.run(); System.out.println("this is MyThread"); System.out.println("run方法中线程名字:" + Thread.currentThread().getName()); &#125; public static void main(String[] args)&#123; // 继承Thread MyThread myThread = new MyThread("myThread-name"); myThread.start(); &#125;&#125; 输出内容： 123构造器中线程名字:mainthis is MyThreadrun方法中线程名字:myThread-name 2、isAlive()方法判断当前线程是否处于活跃状态，活跃状态是指线程已经启动并且尚未终止。 测试代码： 1234567891011121314151617public class IsAliveFunc extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println("run is alive = " + this.isAlive()); &#125; public static void main(String[] args)&#123; IsAliveFunc isAliveFunc = new IsAliveFunc(); System.out.println("begin start " + isAliveFunc.isAlive()); isAliveFunc.start(); System.out.println("after start " + isAliveFunc.isAlive()); &#125;&#125; 输出结果： 123begin start falseafter start truerun is alive = true 3、sleep()方法sleep()方法是让正在运行的线程在指定毫秒数内暂停。 测试代码： 123456789101112131415161718public class SleepFunc &#123; public static void sleep()&#123; System.out.println(&quot;begin&quot;); try &#123; Thread.sleep(2000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;end&quot;); &#125; public static void main(String[] args)&#123; System.out.println(&quot; begin time = &quot; + System.currentTimeMillis()); sleep(); System.out.println(&quot; end time = &quot; + System.currentTimeMillis()); &#125;&#125; 输出结果： 1234begin time = 1551138333348beginendend time = 1551138335348 可以看出时间相差2秒。 4、getId()方法获取线程的唯一标识。 5、停止线程停止线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前操作。有以下三种方法终止正在运行中的线程： 使用退出标志，使线程正常退出，就是当run方法完成后终止线程； 使用stop方法钱箱终止线程，但是不推荐，因为stop和suspend及resume一样是过期作废方法； 使用interrupt中断线程。 5.1 interrupt方法interrupt()方法的使用并不像for+break语句那样，马上就停止循环。调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。所以引出this.interrupted()和this.isInterrupted()方法。 this.interrupted()是判断当前线程是否已经是中断状态，执行此方法后具有将线程的中断状态标志清除为false的功能； this.isInterrupted()是判断当前线程是否已经是中断状态，但是不清除状态标志。 所以使用interrupt()时需要判断线程是否有中断标志，在使用return或者抛异常的方式中断此线程。 5.2 stop()方法stop方法是暴力停止线程，已经弃用的方法不建议使用。而且使用可能会抛出java.lang.ThreadDeath异常。如果强制让线程停止则可能使一些清理性的工作的不能完成。另一种情况就是对锁定的对象解锁，出现数据不一致的情况。 5.3 暂停线程暂停线程可以使用suspend()方法，使用resume()方法恢复。但是这两个方法都是被废弃的方法，不建议使用。这两个方法如果使用不当会造成同步对象的独占，是其他线程无法访问公共同步对象；也有可能产生数据不同步的情况。 所以建议使用wait()方法暂停线程，使用notify()或者notifyAll()方法唤醒线程，这两种方法会在线程后面的文章线程通信部分讲解。 6、yield()方法yield()方法的作用的是放弃当前的CPU资源，将他让给其他的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。 7、线程的优先级在操作系统中，线程可以划分优先级，优先级高的线程得到的CPU资源较多，也就是说CPU优先执行优先级高的线程。线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A线程的一样。 修改优先级的方法是setPriority()。 优先级高的线程总是大部分先执行，但不代表优先级高的线程全部先执行。线程优先级还具有“随机性”，也就是优先级高的线程不一定每次都先执行。 8、守护线程在Java线程中有两种线程，一种是用户线程，另一种就是守护线程。守护线程具有陪伴的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。可以通过调用Thead类的setDaemon(true)方法设置当前的线程为守护线程。 注意事项： setDaemon(true)必须在start()方法前执行，否则会抛出IllegalThreadStateException异常； 在守护线程中产生的新线程也是守护线程 3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。 1234567891011121314151617181920212223242526272829303132333435363738public class DaemonThread extends Thread &#123; private int i = 0; @Override public void run() &#123; super.run(); try &#123; while (true)&#123; i++; System.out.println("i = " + i); Thread.sleep(1000); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;public class DaemonThread extends Thread &#123; private int i = 0; @Override public void run() &#123; super.run(); try &#123; while (true)&#123; i++; System.out.println("i = " + i); Thread.sleep(1000); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果： 1234567i = 1i = 2i = 3i = 4i = 5i = 6我离开thread对象也不再打印了，也就是停止了！ 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（三）——synchronized关键字（下）]]></title>
    <url>%2Fmyblog%2Fpost%2F5f7e4115.html</url>
    <content type="text"><![CDATA[synchronized同步语句块用关键字synchronized声明方法是有弊端的。比如线程A调用同步方法执行一个长时间任务，那么线程B就要等较长时间才能调用。 下面看一个例子： 123456789101112131415161718192021public class Task &#123; private String getData1; private String getData2; public synchronized void longTimeTask()&#123; try &#123; System.out.println("begin task"); Thread.sleep(3000); getData1 = "长时间处理任务后从远程返回的值1 threadName=" + Thread.currentThread().getName(); getData2 = "长时间处理任务后从远程返回的值2 threadName=" + Thread.currentThread().getName(); System.out.println(getData1); System.out.println(getData2); System.out.println("end task"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 12345678public class Utils &#123; public static long begainTime1; public static long endTime1; public static long begainTime2; public static long endTime2;&#125; 12345678910111213141516171819202122232425public class MyThread extends Thread&#123; private Task task; private String name; public MyThread(Task task, String name)&#123; super(); this.task=task; this.name=name; super.setName(name); &#125; @Override public void run() &#123; super.run(); if ("A".equals(name))&#123; Utils.begainTime1 = System.currentTimeMillis(); task.longTimeTask(); Utils.endTime1 = System.currentTimeMillis(); &#125;else &#123; Utils.begainTime2 = System.currentTimeMillis(); task.longTimeTask(); Utils.endTime2 = System.currentTimeMillis(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args)&#123; Task task = new Task(); MyThread myThread = new MyThread(task, "A"); MyThread myThread1 = new MyThread(task, "B"); myThread.start(); myThread1.start(); try &#123; Thread.sleep(10000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; long beginTime = Utils.begainTime1; if (Utils.begainTime2&lt;Utils.begainTime1)&#123; beginTime = Utils.begainTime2; &#125; long endTime = Utils.endTime1; if (Utils.endTime2&gt;Utils.endTime1)&#123; endTime = Utils.endTime2; &#125; System.out.println("耗时：" + (endTime-beginTime)/1000 + "s"); &#125;&#125; 输出内容： 123456789begin task长时间处理任务后从远程返回的值1 threadName=A长时间处理任务后从远程返回的值2 threadName=Aend taskbegin task长时间处理任务后从远程返回的值1 threadName=B长时间处理任务后从远程返回的值2 threadName=Bend task耗时：6s 从运行时间上来看，synchronized方法的问题很明显。可以使用synchronized同步块来解决这个问题。但是要注意synchronized同步块的使用方式，如果synchronized同步块使用不好的话并不会带来效率的提升。 将上文的Task.class文件修改如下： 1234567891011121314151617public void longTimeTask()&#123; try &#123; System.out.println("begin task"); Thread.sleep(3000); String data1 = "长时间处理任务后从远程返回的值1 threadName=" + Thread.currentThread().getName(); String data2 = "长时间处理任务后从远程返回的值2 threadName=" + Thread.currentThread().getName(); synchronized (this)&#123; getData1 = data1; getData2 = data2; &#125; System.out.println(getData1); System.out.println(getData2); System.out.println("end task"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; 输出如下： 123456789begin taskbegin task长时间处理任务后从远程返回的值1 threadName=B长时间处理任务后从远程返回的值2 threadName=Aend task长时间处理任务后从远程返回的值1 threadName=A长时间处理任务后从远程返回的值2 threadName=Aend task耗时：3s 从上面代码可以看出当一个线程访问一个对象的synchronized同步代码块时，另一个线程任然可以访问该对象非synchronized同步代码块。不在synchronized块中的就是异步执行，在synchronized块中就是同步执行。 synchronized代码块之间的同步性当一个线程访问一个对象的synchronized(this)同步代码块时，其他线程对同一个object中的其他synchronized(this)同步代码块访问将被阻塞。 如果在一个类中有很多个synchronized方法，这是虽然能实现同步，但会受到阻塞。如果使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不与其他this同步方法争抢this锁。 静态同步synchronized方法与synchronized(class)代码块关键字synchronized还可以在static方法是使用，是对当前的*.java文件的Class类进行加锁。非静态的synchronized关键字是给对象加锁。 1234567891011121314151617181920212223public static void printA() &#123; synchronized (Service.class) &#123; try &#123; System.out.println( "线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "进入printA"); Thread.sleep(3000); System.out.println( "线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "离开printA"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized public static void printB() &#123; System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "进入printB"); System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "离开printB"); &#125; synchronized public void printC() &#123; System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "进入printC"); System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "离开printC"); &#125; 1234567891011public class Main &#123; public static void main(String[] args)&#123; Service service = new Service(); new Thread(Service::printA, "A").start(); new Thread(Service::printB, "B").start(); new Thread(() -&gt; service.printC(), "C").start(); &#125;&#125; 输出内容： 123456线程名称为：A在1552262297299进入printA线程名称为：C在1552262297300进入printC线程名称为：C在1552262297300离开printC线程名称为：A在1552262300301离开printA线程名称为：B在1552262300301进入printB线程名称为：B在1552262300301离开printB 从运行结果可以看出:静态同步synchronized方法与synchronized(class)代码块持有的锁一样，都是Class锁，Class锁对对象的所有实例起作用。synchronized关键字加到非static静态方法上持有的是对象锁。线程A,B和线程C持有的锁不一样，所以A和B运行同步，但是和C运行不同步。 数据类型String的常量池特性JVM具有String常量池缓存的功能，将synchronized(string)与String联合使用时会出现一些问题。 123String s1 = "a"; String s2="a"; System.out.println(s1==s2);//true 比如两个同步方法都是synchronized(“abc”){}那么多线程会持有相同的锁，所以大多数同步代码块不用String作为锁。 本文代码：GitHub 欢迎关注公众号：]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fmyblog%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SonarQube使用以及集成Jenkins]]></title>
    <url>%2Fmyblog%2Fpost%2F1b40a6fb.html</url>
    <content type="text"><![CDATA[[TOC] 简介sonarQube能够提供对代码的一整套检查扫描和分析功能，拥有一套服务器端程序，然后再通过客户端或者别的软件的插件的形式完成对各开发环境和软件的支持。 对编程语言的支持非常广泛，包括C、C++、Java、Objective C、Python、JavaScript、PHP、C#、Swift、Erlang、Groovy等众多语言 提供了对HTML、CSS、JSON、XML、CSV、SQL、JSP/JSF等类型的文档的支持 提供了以FindBugs、PMD、CheckStyle方式执行代码分析和测试检查的功能 登录认证方式支持LDAP、Bitbucket、Azure Active Directory（AAD）、Crowd等方式 提供了优美的3D视图方式下查看代码分析和测试结果报告 工具sonarQube SonarQube+Scanner jdk1.8 Mysql 5.7 安装下载sonarqube解压，可以在bin目录下找到相关系统的启动执行文件 bin 此目录放置各操作系统（LInux、Windows、MacOS）用于启动 SonarQube 服务的工具、脚本； conf 此目录存放SonarQube相关配置文件； data 此目录包含嵌入式数据库(H2数据库引擎)的数据，建议只用于测试和演示； elasticsearch 此目录放置elasticsearch检索引擎相关内容； extensions 此目录存放SonarQube的插件、 扩展jar 包； lib 此目录存放SonarQube所依赖的 jar 包； logs 此目录存放SonarQube相关日志信息； tmp此目录包含服务器所需的临时数据，服务器启动时不要清理； web 此目录存放 SonarQube web 服务的静态资源。 数据库配置 mysql中新建数据库sonarqube 到conf目录下修改sonar.properties文件 增加数据库连接信息： 1234sonar.jdbc.url=jdbc:mysql://172.16.30.228:3306/qjfsonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformancesonar.jdbc.username=gmsdsonar.jdbc.password=gmsdtradesonar.sorceEncoding=UTF-8 启动服务启动服务前可以先设置服务登录用户，端口默认是9000。 123sonar.login=adminsonar.password=admin#sonar.web.port=9000 进入bin目录下找到对应系统启动文件，以Windows为例，执行StartSonar.bat。稍微有点慢，因为要初始化数据库信息，.数据库初始化成功后，登录。 数据库增加的表： 汉化进入官网下载中文插件。 代码质量分析有三种方式来进行代码分析： Analyzing with SonarQube Runner Analyzing with SonarQube Ant Task Analyzing with Maven 主要讲解第一种方法，其他两种方法可以参考这篇文章，感兴趣可以自行查找资料。 SonarQube Runner适用于所有不同架构的项目，包括没有使用任何源代码管理工具的项目形式，以及使用各种不同代码管理工具（SVN、Git、ClearCase 等）和编译工具（ant，maven）的项目形式，它都能够适用。 需要的工具1、下载对应版本的 SonarQube+Scanner ，本地解压。修改/conf/sonar-scanner.properties文件。 123456789101112#Configure here general information about the environment, such as SonarQube server connection details for example#No information about specific project should appear here#----- SonarQube 服务器地址sonar.host.url=http://localhost:9000#----- Default source code encodingsonar.sourceEncoding=UTF-8数据库连接（可以省略）sonar.jdbc.url=jdbc:mysql://localhost:3306/sonarqube?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformancesonar.jdbc.username=rootsonar.jdbc.password=abc123 2、配置环境变量，name=SONAR_RUNNER_HOME。value=D:\sonar\sonar-scanner-3.2，在Path中添加输入%SONAR_RUNNER_HOME%\bin; 打开终端输入：sonar-scanner -version，出现如下内容说明配置成功：3、在需要扫描的项目的根目录下添加sonar-project.properties文件 12345678910111213141516# must be unique in a given SonarQube instancesonar.projectKey=my:project# this is the name displayed in the SonarQube UIsonar.projectName=apiautocoresonar.projectVersion=1.0 # Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.# Since SonarQube 4.2, this property is optional if sonar.modules is set. # If not set, SonarQube starts looking for source code from the directory containing # the sonar-project.properties file.sonar.sources=.# Encoding of the source code. Default is default system encodingsonar.sourceEncoding=UTF-8#语言可以省略，参考sonarqube服务的配置-&gt;通用配置的各种语言后缀，python是py# sonar.language=java# java文件需要添加sonar.java.binaries=*/classes sonar.projectKey需要全局唯一，sonar.source 是用于指定待分析的代码位置的，sonar.projectName是在sonarqube中显示的名称。 4、在项目根目录输入指令：sonar-scanner扫描，再访问sonarqube服务可以查看。 sonarqube平台参数意义1、质量阈：是一系列对项目指标进行度量的条件。项目必须达到所有条件才能算整体上通过了质量阈。点击导航栏中的质量阀按钮，可更改质量阈的标准。 2、可靠性与安全性：项目中存在的bug或者漏洞 可以选择对应的问题查看 3、异味：是指在代码之中潜在问题的警示信号。并非所有的异味所指示的确实是问题，但是对于大多数异味，均很有必要加以查看，并作出相应的修改。 4、债务：修改所需要的时间 其实分析所有有问题的地方都会有解决问题的时间显示： 5、覆盖率：被测试覆盖的代码的比例。 可以查看单元测试覆盖率。 代码中会有不同颜色表示覆盖情况： 6、重复：代码重复情况 默认质量阈：1、可维护性： 可维护性的评定标准是项目评级与您的技术债务比率相关。默认的可维护性评级是： A = 0-0.05，B = 0.06-0.1，C = 0.11-0.20，D = 0.21-0.5，E = 0.51-1 计算方式是按照技术债务比率计算的： 技术债务比率 = 修复软件成本 /（修改一行代码所需要的时间 * 代码总行数） 2、可靠性： 可靠性是指项目错误问题的数量，评级标准： A = 0错误 B =至少1个小错误 C =至少1个主要错误 D =至少1个严重错误 E =至少1个阻断错误 3、安全性： 漏洞问题的数量，评级标准： A = 0漏洞 B =至少1个次要漏洞 C =至少1个主要漏洞 D =至少1个严重漏洞 E =至少1个阻断漏洞 4、覆盖率： 5、重复 代码规则Sonarqube内置了代码规则，用户可以根据对应代码提供的模板自行编辑新的代码规则。 用户与权限可在配置——&gt;权限——&gt;用户，新建用户。在群组页面可以建立项目群组。将用户划分到某个群组中。 设置权限时可以单独对用户或者对群组设置权限，访问某一项目的分析页面。 项目管理可以批量对项目进行权限划分。 应用市场下载插件，也可以到官网下载插件放到服务目录下面 令牌本地或者使用Jenkins等分析代码时，可以使用令牌生成的秘钥登录服务上传项目。 集成Jenkins安装插件SonarQube Scanner for Jenkins管理员权限登录Jenkins，选择：系统管理–&gt;插件管理–&gt;可选插件；搜索SonarQube Scanner for Jenkins，勾选，安装后重新启动JenKins。 配置sonar1、系统管理–&gt;全局工具配置 选择新增SonarQube Scanner添加scanner的路径保存 2、系统设置中添加全局属性 3、设置sonar的服务地址 Server authentication token 可以在sonar服务中获取 填写令牌名称点击生成即可。 4、任务配置 选择第一个 添加jdk版本，填入项目文件中sonar-project.properties的内容 保存构建项目即可。 可以根据Jenkins上点击跳转到SonarQube上查看项目分析结果。 关于单元测试和覆盖率不显示问题在java项目中增加jacoco插件 123456789101112131415161718192021222324252627&lt;!-- 单元测试覆盖率 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.7.201606060606&lt;/version&gt; &lt;configuration&gt; &lt;!--指定生成.exec文件的存放位置--&gt; &lt;destFile&gt;target/coverage-reports/jacoco-unit.exec&lt;/destFile&gt; &lt;!--Jacoco是根据.exec文件生成最终的报告，所以需指定.exec的存放路径--&gt; &lt;dataFile&gt;target/coverage-reports/jacoco-unit.exec&lt;/dataFile&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;jacoco-initialize&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;jacoco-site&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; properties增加内容或者可不添加 12345sonar.java.coveragePlugin=jacocosonar.jacoco.reportPaths=./target/coverage-reports/jacoco-unit.execsonar.dynamicAnalysis=reuseReports 重新部署即可。 ps：如果用jenkins部署，项目中可以不用添加sonar-project.properties文件，将文件内容写在jenkins中即可。 参考资料：https://www.ibm.com/developerworks/cn/opensource/os-sonarqube/ http://blog.51cto.com/13538361/2070412 https://www.jianshu.com/p/778fd35fd494 http://www.cnblogs.com/qiumingcheng/p/7253917.html https://blog.csdn.net/w171066/article/details/52366627 https://blog.csdn.net/lswnew/article/details/79193529 https://blog.csdn.net/t3369/article/details/77977821 单元测试覆盖率]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>SonarQube</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（八）——建造者模式]]></title>
    <url>%2Fmyblog%2Fpost%2F1c2e1353.html</url>
    <content type="text"><![CDATA[建造者模式讲一个复杂构建与他的表示分离，使得同样的构建可以创建不同的表示。 优点 封装性：客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。例子中，惠普和苹果建造者互相独立。 便于控制细节风险。 应用场景 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性。 隔离复杂对象的创建和使用，并使得形同的创建过程可以创建不同的产品。 相同方法，不同的执行顺序。 代码GitHUb 新建一个产品类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Computer &#123; private String CPU; private String capacity; private String ram; private String system; public String getCPU() &#123; return CPU; &#125; public void setCPU(String CPU) &#123; this.CPU = CPU; &#125; public String getCapacity() &#123; return capacity; &#125; public void setCapacity(String capacity) &#123; this.capacity = capacity; &#125; public String getRam() &#123; return ram; &#125; public void setRam(String ram) &#123; this.ram = ram; &#125; public String getSystem() &#123; return system; &#125; public void setSystem(String system) &#123; this.system = system; &#125; @Override public String toString() &#123; return "Computer&#123;" + "CPU='" + CPU + '\'' + ", capacity='" + capacity + '\'' + ", ram='" + ram + '\'' + ", system='" + system + '\'' + '&#125;'; &#125;&#125; 建造者接口： 1234567891011public interface IBuildComputer &#123; void buildCPU(); void buildCapacity(); void buildRam(); void buildSystem(); Computer createComputer();&#125; 具体建造者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class HPComputer implements IBuildComputer &#123; private Computer computer; public HPComputer()&#123; computer = new Computer(); &#125; @Override public void buildCPU() &#123; computer.setCPU("惠普cpu"); &#125; @Override public void buildCapacity() &#123; computer.setCapacity("560G"); &#125; @Override public void buildRam() &#123; computer.setRam("16G"); &#125; @Override public void buildSystem() &#123; computer.setSystem("windows10"); &#125; @Override public Computer createComputer() &#123; return computer; &#125;&#125;public class AppleComputer implements IBuildComputer &#123; private Computer computer; public AppleComputer()&#123; computer = new Computer(); &#125; @Override public void buildCPU() &#123; computer.setCPU("苹果cpu"); &#125; @Override public void buildCapacity() &#123; computer.setCapacity("256G"); &#125; @Override public void buildRam() &#123; computer.setRam("16G"); &#125; @Override public void buildSystem() &#123; computer.setSystem("macOS"); &#125; @Override public Computer createComputer() &#123; return computer; &#125;&#125; Director导演类，负责安排已有模块顺序： 12345678910public class Director &#123; public Computer createComputerByDirector(IBuildComputer computer)&#123; computer.buildCapacity(); computer.buildCPU(); computer.buildRam(); computer.buildSystem(); return computer.createComputer(); &#125;&#125; 测试 1234567891011public class Main &#123; public static void main(String[] args)&#123; Director director = new Director(); Computer hp = director.createComputerByDirector(new HPComputer()); System.out.println(hp.toString()); System.out.println("-----------------------"); Computer apple = director.createComputerByDirector(new AppleComputer()); System.out.println(apple.toString()); &#125;&#125; 结果 123Computer&#123;CPU=&apos;惠普cpu&apos;, capacity=&apos;560G&apos;, ram=&apos;16G&apos;, system=&apos;windows10&apos;&#125;-----------------------Computer&#123;CPU=&apos;苹果cpu&apos;, capacity=&apos;256G&apos;, ram=&apos;16G&apos;, system=&apos;macOS&apos;&#125;]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（七）——模板模式]]></title>
    <url>%2Fmyblog%2Fpost%2F4577e683.html</url>
    <content type="text"><![CDATA[[TOC] 模板模式定义一个操作中的算法框架，将一些步骤延迟到子类中，使子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。 子类重写或实现父类的方法。再由父类的模板方法调用这些公共的方法。所以被子类重写或者不必暴露的方法一般定义为私有的。 优点 封装不变不封，扩展可变部分。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。 使用场景 多个子类有公共的方法，并且逻辑基本相同。 重要、复杂的算法，可以把核心算法设计为模板方法，相关细节由子类实现。 重构时候，经相同代码提取到父类，再通过钩子函数约束其行为。 代码GitHub 定义抽象模板类 123456789101112public abstract class AbstractTemplate &#123; protected abstract void method1(); protected abstract void method2(); public void method()&#123; this.method1(); this.method2(); &#125;&#125; 定义子类实现 123456789101112131415161718192021222324public class ConcreteTemplate1 extends AbstractTemplate &#123; @Override protected void method1() &#123; System.out.println("模板1业务逻辑方法1");&#125; @Override protected void method2() &#123; System.out.println("模板1业务逻辑方法2"); &#125;&#125;public class ConcreteTemplate2 extends AbstractTemplate &#123; @Override protected void method1() &#123; System.out.println("模板2业务逻辑方法1"); &#125; @Override protected void method2() &#123; System.out.println("模板2业务逻辑方法2"); &#125;&#125; 测试类 123456789public static void main(String[] args)&#123; AbstractTemplate template1 = new ConcreteTemplate1(); AbstractTemplate template2 = new ConcreteTemplate2(); template1.method(); System.out.println("-----------------"); template2.method();&#125; 12345模板1业务逻辑方法1模板1业务逻辑方法2-----------------模板2业务逻辑方法1模板2业务逻辑方法2]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（六）——组合模式]]></title>
    <url>%2Fmyblog%2Fpost%2Fd5f77bab.html</url>
    <content type="text"><![CDATA[组合模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 一致性指的是这些对象都具有相同的接口。 优点： 高层模块调用简单 节点自有增加，容易扩展。 缺点：直接调用实现类，不符合依赖倒置原则。 使用场景 维护和展示部分整体关系场景，如菜单、文件和文件夹管理等。 从一个整体中能够独立出部分模块或功能的场景。 透明方式父类包含所有子类方法，父类方法是抽象的。不需要该方法的子类可以选择throw Exception。 优点: 各个子类完全一致，可以使用父类接口调用。 缺点： 子类实现无意义方法。 安全方式子类特有的方法，留到具体子类中实现。树枝节点和树叶节点彻底分开。 缺点： 所有子类不再具有相同接口。 代码实现GitHub 例子是透明方式实现的组合模式 Compent 抽象构件，定义参加组合对象的共有方法和属性。 123456789101112131415public abstract class Component &#123; protected String name; public Component(String name)&#123; this.name = name; &#125; abstract void add(Component component); abstract void delete(Component component); abstract void show(int index);&#125; Composite树枝构件，组合树枝节点和树叶节点形成一个树形结构。 123456789101112131415161718192021222324252627282930public class Composite extends Component &#123; List&lt;Component&gt; components = new ArrayList&lt;&gt;(); public Composite(String name)&#123; super(name); &#125; @Override void add(Component component) &#123; components.add(component); &#125; @Override void delete(Component component) &#123; components.remove(component); &#125; @Override void show(int index) &#123; StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; index; i++)&#123; stringBuilder.append("-"); &#125; System.out.println(stringBuilder.toString() + this.name); for(Component component : components)&#123; component.show(index + 2); &#125; &#125;&#125; Leaf树叶节点，其下没有其他分支 12345678910111213141516171819202122232425public class Leaf extends Component &#123; public Leaf(String name)&#123; super(name); &#125; @Override void add(Component component) &#123; System.out.println("树叶节点没有此功能"); &#125; @Override void delete(Component component) &#123; System.out.println("树叶节点没有此功能"); &#125; @Override void show(int index) &#123; StringBuilder stringBuilder = new StringBuilder(); for(int i = 0; i &lt; index; i++)&#123; stringBuilder.append("-"); &#125; System.out.println(stringBuilder.toString() + this.name); &#125;&#125; 测试类 12345678910111213141516171819202122public static void main(String[] args)&#123; Composite root = new Composite("root"); root.add(new Leaf("leaf1")); Leaf leaf = new Leaf("leaf2"); root.add(leaf); Composite composite = new Composite("composite"); composite.add(new Leaf("leaf3")); composite.add(new Leaf("leaf4")); composite.add(new Leaf("leaf5")); root.add(composite); root.show(1); System.out.println("==================="); root.delete(leaf); root.show(1); System.out.println("==================="); composite.show(1);&#125; 返回信息 12345678910111213141516171819-root---leaf1---leaf2---composite-----leaf3-----leaf4-----leaf5===================-root---leaf1---composite-----leaf3-----leaf4-----leaf5===================-composite---leaf3---leaf4---leaf5]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（五）——装饰模式]]></title>
    <url>%2Fmyblog%2Fpost%2F97b0416b.html</url>
    <content type="text"><![CDATA[[TOC] 装饰器模式动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更灵活。 在装饰模式中， 必然有一个最基本、 最核心、 最原始的接口或抽象类充当 Component抽象构件。 优点 装饰类和被装饰类可以独立发展，不会互相耦合。 装饰器模式是继承关系的替代方案 装饰器模式可以动态的扩展一个实现类的功能。 缺点多层装饰比较复杂。尽量减少装饰类数量，以便降低系统复杂度。 代码GitHub 定义一个接口或者一个抽象类，装饰器中最基本最核心对象。 1234public interface Component &#123; void method();&#125; 定义具体构件，Component的实现，被装饰类 123456public class ConcreteComponent implements Component &#123; @Override public void method() &#123; System.out.println("原来的方法"); &#125;&#125; 定义装饰角色，实现接口或抽象方法，属性里有一个private变量指向Component抽象构件。 1234567891011121314public abstract class Decorator implements Component&#123; private Component component; public Decorator(Component component)&#123; super(); this.component = component; &#125; @Override public void method() &#123; component.method(); &#125;&#125; Decorator类并不是必须的。 具体的装饰类： 123456789101112131415161718192021222324252627282930313233343536public class ConcreteDecorator1 extends Decorator &#123; public ConcreteDecorator1(Component component)&#123; super(component); &#125; public void method1()&#123; System.out.println("装饰器1装饰"); &#125; @Override public void method()&#123; System.out.println("增加装饰1包装"); super.method(); System.out.println("装饰1包装结束"); &#125;&#125;public class ConcreteDecorator2 extends Decorator &#123; public ConcreteDecorator2(Component component)&#123; super(component); &#125; public void method2()&#123; System.out.println("装饰器2装饰"); &#125; @Override public void method()&#123; System.out.println("增加装饰2包装"); super.method(); System.out.println("装饰2包装结束"); &#125;&#125; main方法测试 1234567891011121314151617181920212223242526public static void main(String[] args)&#123; //原来对象 Component component = new ConcreteComponent(); component.method(); System.out.println("-------------------------"); //被装饰1修饰 ConcreteDecorator1 component1 = new ConcreteDecorator1(component); component1.method1(); component1.method(); System.out.println("-------------------------"); //被装饰2修饰 ConcreteDecorator2 component2 = new ConcreteDecorator2(component); component2.method2(); component2.method(); System.out.println("-------------------------"); //多重装饰 Component component3 = new ConcreteDecorator2(new ConcreteDecorator1(new ConcreteComponent())); component3.method(); System.out.println("-------------------------"); Component component4 = new ConcreteDecorator1(new ConcreteDecorator2(new ConcreteComponent())); component4.method();&#125; 测试结果： 1234567891011121314151617181920212223原来的方法-------------------------装饰器1装饰增加装饰1包装原来的方法装饰1包装结束-------------------------装饰器2装饰增加装饰2包装原来的方法装饰2包装结束-------------------------增加装饰2包装增加装饰1包装原来的方法装饰1包装结束装饰2包装结束-------------------------增加装饰1包装增加装饰2包装原来的方法装饰2包装结束装饰1包装结束 装饰器模式使用场景 需要扩展一个类的功能，或给一个类增加附加功能； 动态的给一个对象增加附加功能，这些功能可以再动态的撤销； 为一批兄弟类进行改装或增加功能。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（四）——代理模式]]></title>
    <url>%2Fmyblog%2Fpost%2Fceb9d73b.html</url>
    <content type="text"><![CDATA[[TOC] 代理模式定义：为其他对象提供一种代理以控制对这个对象的访问 上图中，Subject是一个抽象类或者接口，RealSubject是实现方法类，具体的业务执行，Proxy则是RealSubject的代理，直接和client接触的。 代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。 代理模式优点 职责清晰 高扩展，只要实现了接口，都可以用代理。 智能化，动态代理。 分类代码：GitHub 1、静态代理以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。 首先定义一个提供了租房方法的接口。 123public interface IRentHose &#123; void rentHose();&#125; 定义租房的实现类 123456public class RentHose implements IRentHose &#123; @Override public void rentHose() &#123; System.out.println("租了一间房子。。。"); &#125;&#125; 我要租房，房源都在中介手中，所以找中介 123456789101112131415public class IntermediaryProxy implements IRentHose &#123; private IRentHose rentHose; public IntermediaryProxy(IRentHose irentHose)&#123; rentHose = irentHose; &#125; @Override public void rentHose() &#123; System.out.println("交中介费"); rentHose.rentHose(); System.out.println("中介负责维修管理"); &#125;&#125; 这里中介也实现了租房的接口。 再main方法中测试 1234567891011public class Main &#123; public static void main(String[] args)&#123; //定义租房 IRentHose rentHose = new RentHose(); //定义中介 IRentHose intermediary = new IntermediaryProxy(rentHose); //中介租房 intermediary.rentHose(); &#125;&#125; 返回信息 123交中介费租了一间房子。。。中介负责维修管理 这就是静态代理，因为中介这个代理类已经事先写好了，只负责代理租房业务 2、强制代理如果我们直接找房东要租房，房东会说我把房子委托给中介了，你找中介去租吧。这样我们就又要交一部分中介费了，真坑。 来看代码如何实现，定义一个租房接口，增加一个方法。 1234public interface IRentHose &#123; void rentHose(); IRentHose getProxy();&#125; 这时中介的方法也稍微做一下修改 123456789101112131415161718public class IntermediaryProxy implements IRentHose &#123; private IRentHose rentHose; public IntermediaryProxy(IRentHose irentHose)&#123; rentHose = irentHose; &#125; @Override public void rentHose() &#123; rentHose.rentHose(); &#125; @Override public IRentHose getProxy() &#123; return this; &#125;&#125; 其中的getProxy()方法返回中介的代理类对象 我们再来看房东是如何实现租房： 12345678910111213141516171819202122232425262728293031public class LandLord implements IRentHose &#123; private IRentHose iRentHose = null; @Override public void rentHose() &#123; if (isProxy())&#123; System.out.println("租了一间房子。。。"); &#125;else &#123; System.out.println("请找中介"); &#125; &#125; @Override public IRentHose getProxy() &#123; iRentHose = new IntermediaryProxy(this); return iRentHose; &#125; /** * 校验是否是代理访问 * @return */ private boolean isProxy()&#123; if(this.iRentHose == null)&#123; return false; &#125;else&#123; return true; &#125; &#125;&#125; 房东的getProxy方法返回的是代理类，然后判断租房方法的调用者是否是中介，不是中介就不租房。 main方法测试： 12345678910111213 public static void main(String[] args)&#123; IRentHose iRentHose = new LandLord(); //租客找房东租房 iRentHose.rentHose(); //找中介租房 IRentHose rentHose = iRentHose.getProxy(); rentHose.rentHose(); &#125;&#125; 12请找中介租了一间房子。。。 看，这样就是强制你使用代理，如果不是代理就没法访问。 3、动态代理我们知道现在的中介不仅仅是有租房业务，同时还有卖房、家政、维修等得业务，只是我们就不能对每一个业务都增加一个代理，就要提供通用的代理方法，这就要通过动态代理来实现了。 中介的代理方法做了一下修改 123456789101112131415161718192021222324public class IntermediaryProxy implements InvocationHandler &#123; private Object obj; public IntermediaryProxy(Object object)&#123; obj = object; &#125; /** * 调用被代理的方法 * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = method.invoke(this.obj, args); return result; &#125;&#125; 在这里实现InvocationHandler接口，此接口是JDK提供的动态代理接口，对被代理的方法提供代理。其中invoke方法是接口InvocationHandler定义必须实现的， 它完成对真实方法的调用。动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理就会实现接口下所有的方法。通过 InvocationHandler接口， 所有方法都由该Handler来进行处理， 即所有被代理的方法都由 InvocationHandler接管实际的处理任务。 这里增加一个卖房的业务，代码和租房代码类似。 main方法测试： 123456789101112131415161718public static void main(String[] args)&#123; IRentHose rentHose = new RentHose(); //定义一个handler InvocationHandler handler = new IntermediaryProxy(rentHose); //获得类的class loader ClassLoader cl = rentHose.getClass().getClassLoader(); //动态产生一个代理者 IRentHose proxy = (IRentHose) Proxy.newProxyInstance(cl, new Class[]&#123;IRentHose.class&#125;, handler); proxy.rentHose(); ISellHose sellHose = new SellHose(); InvocationHandler handler1 = new IntermediaryProxy(sellHose); ClassLoader classLoader = sellHose.getClass().getClassLoader(); ISellHose proxy1 = (ISellHose) Proxy.newProxyInstance(classLoader, new Class[]&#123;ISellHose.class&#125;, handler1); proxy1.sellHose();&#125; 12租了一间房子。。。买了一间房子。。。 在main方法中我们用到了Proxy这个类的方法， 123public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) loder：类加载器，interfaces：代码要用来代理的接口， h：一个 InvocationHandler 对象 。 InvocationHandler 是一个接口，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。 12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。 因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。 总结 静态代理，代理类需要自己编写代码写成。 动态代理，代理类通过 Proxy.newInstance() 方法生成。 JDK实现的代理中不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。CGLib可以不需要接口。 动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（三）——工厂模式]]></title>
    <url>%2Fmyblog%2Fpost%2F9312851b.html</url>
    <content type="text"><![CDATA[工厂模式​ 定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法是一个类的实例化延迟到子类。 工厂方法可以解耦，降低代码的重复性。 工厂模式分类 简单工厂：静态工厂方法，一个模块仅需要一个工厂类， 没有必要把它产生出来。 工厂方法：多个工厂 抽象工厂：为创建一组相关或相互依赖的对象提供一个接口， 而且无须指定它们 的具体类。 代码：GitHub 简单工厂方法一个模块仅需要一个工厂类， 没有必要把它产生出来， 使用静态的方法就可以了。在需要创建对象较少，调用者也比较简单时候使用。 缺点是工厂类的扩展比 较困难， 不符合开闭原则（可以通过反射方法创建实例） 定义一个动物类： 123public class Animal &#123; public void howl() &#123;&#125;&#125; 定义一个猫类继承动物类： 123456public class Cat extends Animal&#123; @Override public void howl() &#123; System.out.println("猫在喵喵叫"); &#125;&#125; 定义一个狗继承动物类： 123456public class Dog extends Animal&#123; @Override public void howl() &#123; System.out.println("狗在汪汪叫"); &#125;&#125; 创建一个动物工厂： 12345678910111213141516public class AnimalFactory &#123; public static Object createAnimal(Class&lt;? extends Animal&gt; clazz)&#123; Object obj = null; try &#123; obj = Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 工厂类通过反射方法创建实例。 工厂方法不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂 。 优点： 调用者不需要知道具体产品类的类名，只需要知道它的工厂即可。 抽象工厂类只需要提供接口，由子类负责创建具体的对象。 缺点： 可扩展性和维护性不友好。如果要扩展一个产品类， 就需要建立一个相应的工厂类， 这样就增加了扩展的难度。 因为工厂类和产品类的数量相同， 维护时需要考虑两个对象之间的关系。 定义一个动物的抽象类： 1234567public abstract class AbstractAnimal &#123; /** * 所有动物都会叫，叫声不同 */ public abstract void howl();&#125; 一个生产动物的工厂： 1234567public interface AnimalFactory &#123; /** * 获取一个动物 * @return */ AbstractAnimal createAnimal();&#125; 猫和狗的工厂： 1234567891011121314public class CatFactory implements AnimalFactory &#123; @Override public AbstractAnimal createAnimal() &#123; return new Cat(); &#125;&#125;public class DogFactory implements AnimalFactory &#123; @Override public AbstractAnimal createAnimal() &#123; return new Dog(); &#125;&#125; 抽象工厂方法有多个业务类型和分类时候，可以用抽象工厂模式生产需要的对象。 抽象工厂和工厂方法的区别：抽象工厂是生产对产品有结构划分的产品，工厂方法只生成单一产品。以猫和狗为例，现在要区分公母。也就是说有公猫和母猫，以及公狗和母狗。每个产品多了一层约束。 优点： 封装性。不关系对象如何创建。 产品族内约束为非公开状态，具体产品族内约束在工厂内实现。 缺点： 产品族扩展难。增加一个产品，抽象类就要多一个方法。但是产品等级扩展相对容易。例如动物工厂在增加一种性别类型，就要在多一个抽象工厂和实现类。如果要增加一种动物只需要增加一个子类就可以了。 工厂方法的扩展1、代替单例模式，可以用简单工厂方法通过反射创建单例。该框架可以继续扩展， 在一个项目中可以 产生一个单例构造器， 所有需要产生单例的类都遵循一定的规则（构造方法是private） ， 然 后通过扩展该框架， 只要输入一个类型就可以获得唯一的一个实例。 12345678public class Singleton &#123; private Singleton()&#123;&#125; public void doSomething()&#123; System.out.println("工厂方法创建的单例模式"); &#125;&#125; 通过简单工厂方法创建单例 123456789101112131415161718192021public class SingletonFactory &#123; private static Singleton singleton; static&#123; try &#123; Class cl= Class.forName(Singleton.class.getName()); //获得无参构造 Constructor constructor=cl.getDeclaredConstructor(); //设置无参构造是可访问的 constructor.setAccessible(true); //产生一个实例对象 singleton = (Singleton)constructor.newInstance(); &#125; catch (Exception e) &#123; //异常处理 System.out.println("异常"); &#125; &#125; public static Singleton getSingleton()&#123; return singleton; &#125;&#125; 2、延迟初始化：一个对象被消费完毕后， 并不立刻释放， 工厂类 保持其初始状态， 等待再次被使用。 延迟初始化是工厂方法模式的一个扩展应用。 123456789101112131415161718public class ProductFactory &#123; private static final Map&lt;String,Product&gt; prMap = new HashMap&lt;&gt;(); public static synchronized Product createProduct(String type) throws Exception&#123; Product product =null; //如果Map中已经有这个对象 if(prMap.containsKey(type))&#123; product = prMap.get(type); &#125;else&#123; if(type.equals("Product1"))&#123; product = new ConcreteProduct1(); &#125;else&#123; product = new ConcreteProduct2();&#125; //同时把对象放到缓存容器中 prMap.put(type,product); &#125; return product; &#125;&#125; ​ 延迟加载框架是可以扩展的， 例如限制某一个产品类的最大实例化数量， 可以通过判断 Map中已有的对象数量来实现， 这样的处理是非常有意义的， 例如JDBC连接数据库， 都会 要求设置一个MaxConnections最大连接数量， 该数量就是内存中最大实例化的数量。 ​ 延迟加载还可以用在对象初始化比较复杂的情况下， 例如硬件访问， 涉及多方面的交 互， 则可以通过延迟加载降低对象的产生和销毁带来的复杂性。 总结​ 工厂方法模式是new一个对象的替代品， 所以在所有需要生成对象的地方都可以使用， 但是需要慎重地考虑是否要增加一个工厂类进行管理， 增加代码的复杂度。 ​ 需要灵活的、 可扩展的框架时， 可以考虑采用工厂方法模式。 万物皆对象， 那万物也就皆产品类， 例如需要设计一个连接邮件服务器的框架， 有三种网络协议可供选择： POP3、 IMAP、 HTTP， 我们就可以把这三种连接方法作为产品类， 定义一个接口如 IConnectMail， 然后定义对邮件的操作方法， 用不同的方法实现三个具体的产品类（也就是 连接方式） 再定义一个工厂方法， 按照不同的传入条件， 选择不同的连接方式。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（二）——单例模式]]></title>
    <url>%2Fmyblog%2Fpost%2F9015327f.html</url>
    <content type="text"><![CDATA[单例模式​ 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。构造器私有化，不能被new出来。 项目代码：Github 单例的应用优点 在内存中只有一个实例， 减少了内存开支 当一个对象的产生需要 比较多的资源时， 如读取配置、 产生其他依赖对象时， 则可以通过在应用启动时直接产生一 个单例对象， 然后用永久驻留内存的方式来解决 单例模式可以避免对资源的多重占用， 例如一个写文件动作， 由于只有一个实例存在 内存中， 避免对同一个资源文件的同时写操作。 单例模式可以避免对资源的多重占用， 例如一个写文件动作， 由于只有一个实例存在 内存中， 避免对同一个资源文件的同时写操作。 缺点 单例模式一般没有接口， 扩展很困难； 单例模式对测试是不利的。 在并行开发环境中， 如果单例模式没有完成， 是不能进行 测试的， 没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。 几种单例实现： 1、饿汉模式1234567891011121314public class SingleDemo &#123; private static SingleDemo instance = new SingleDemo(); //私有化构造器 private SingleDemo() &#123; //防止其他通过反射调用构造方法，破解单例 if (instance != null) &#123; throw new RuntimeException(); &#125; &#125; //对外提供统一的访问点 public static SingleDemo getInstance() &#123; return instance; &#125;&#125; 优点： 实例的初始化由JVM装载类的时候进行，保证了线程的安全性 实现简单方便，访问效率高 缺点： 不能实现懒加载，资源的利用率不高 2、懒汉模式12345678910111213141516171819public class SingleDemo2 &#123; // 此处并不初始化实例 private static SingleDemo2 instance; private SingleDemo2() &#123; if (instance != null) &#123; throw new RuntimeException(); &#125; &#125; /** * 当调用此方法的时候才初始化实例， 为了实现线程安全，需要使用同步方法 */ public static synchronized SingleDemo2 getInstance() &#123; if (instance == null) &#123; instance = new SingleDemo2(); &#125; return instance; &#125;&#125; 优点： 只有使用这个类的时候才初始化实例，优化了资源利用率 缺点： 为了实现线程安全，使用了同步方法获取，增加了访问的开销 3、双重检查12345678910111213141516171819202122public class SingleDemo3 &#123; private static SingleDemo3 instance; private SingleDemo3() &#123; if (instance != null) &#123; throw new RuntimeException(); &#125; &#125; public static SingleDemo3 getInstance() &#123; //第一重检查，提高效率 if (instance == null) &#123; synchronized (SingleDemo3.class) &#123; //第二重检查保证线程安全 if (instance == null) &#123; instance = new SingleDemo3(); &#125; &#125; &#125; return instance; &#125;&#125; 优点： 实现懒加载 通过缩小同步区域和第一次检查提高访问效率 缺点： 为了实现线程安全，使用了同步方法获取，增加了访问的开销 4、静态内部类123456789101112131415161718192021public class SingleDemo4 &#123; private static SingleDemo4 instance; private static class SingleDemo4Holder &#123; private static final SingleDemo4 instance = new SingleDemo4(); &#125; private SingleDemo4() &#123; if (instance != null) &#123; throw new RuntimeException(); &#125; &#125; /** * 调用这个方法的时候，JVM才加载静态内部类，才初始化静态内部类的类变量。由于由JVM初始化，保证了线程安全性， * 同时又实现了懒加载 */ public static SingleDemo4 getInstance() &#123; return SingleDemo4Holder.instance; &#125;&#125; 优点： 即实现了线程安全，又实现了懒加载 缺点： 实现稍显复杂 5、枚举类123456public enum SingleDemo5 &#123; INSTANCE; public void someMethod()&#123; &#125;&#125; 优点： 实现简单 线程安全 缺点： 不能实现懒加载 结论如果需要懒加载就使用静态内部类方式，如果不需要就使用枚举方式 单例模式的扩展如果要求一个类只能生产固定数量的实例。 1234567891011121314151617181920212223public class SingleDemo6&#123; // 最多可以生成的单例数量 private static int maxNumberSingleDemo = 2; // 定义列表存放实例 private static List&lt;SingleDemo6&gt; singleDemoList = new ArrayList&lt;&gt;(); //生成对象 static&#123; for(int i=0; i&lt;maxNumberSingleDemo; i++)&#123; singleDemoList.add(new SingleDemo6()); &#125; &#125; private SingleDemo6()&#123;&#125; public static SingleDemo6 getInstance()&#123; Random random = new Random(); //随机调用一个实例 int number = random.nextInt(maxNumberSingleDemo); return singleDemoList.get(number); &#125; &#125; 这种需要产生固定数量对象的模式就叫做有上限的多例模式， 它是单例模式的一种扩展， 采用有上限的多例模式， 我们可以在设计时决定在内存中有多少个实例， 方便系统进行 扩展， 修正单例可能存在的性能问题， 提供系统的响应速度。 例如读取文件， 我们可以在系 统启动时完成初始化工作， 在内存中启动固定数量的reader实例， 然后在需要读取文件时就 可以快速响应。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（一）]]></title>
    <url>%2Fmyblog%2Fpost%2Fe6fb3acf.html</url>
    <content type="text"><![CDATA[[TOC] 设计原则一、单一职责原则​ 有且仅有一个原因引起类的变更。 优点： 类的复杂性降低，实现什么职责都有明确的定义； 可读性提高； 可维护性提高； 变更引起的风险降低。 二、里氏替换原则​ 所有引用基类的地方必须能透明使用其子类的对象。只要父类能出现的地方，子类就可以出现，而且替换子类也不会产生错误。 继承的优点： 代码共享，每个子类都有父类的方法和属性； 提高代码重用性； 提高代码扩展性； 提高产品或项目开放性。 继承的缺点： 具有侵入性，子类有父类的所有属性和方法； 降低代码灵活性； 增强耦合性，父类中常量、变量和方法被修改时，需要考虑子类的修改。 三、依赖倒置原则​ 高层模块不应该依赖底层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。 ​ 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系通过接口或抽象类产生的。接口或抽象类不依赖于实现类，实现类依赖接口或抽象类。 四、接口隔离原则​ 客户端不应依赖它不需要的接口，对接口进行细化；类建的依赖关系应该建立在最小的接口上。建立单一接口，不要建立臃肿庞大的接口。而且要满足单一职责原则。 五、迪米特法则​ 也称最少知识原则：一个对象应该对其他对象有最少的了解。一个类应该对自己需要耦合或调用的类知道的最少。 ​ 只和直接的朋友通信：每个对象都必然与其他对象有耦合关系，两个对象间的耦合就成为朋友关系。 ​ 迪米特法则的核心观念就是类间的解耦，弱耦合。其实就是面向对象编程。 六、开闭原则​ 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。开闭原则可以提高复用性，提高维护性。 抽象约束：通过接口或者抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。 1.通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或者抽象类中不存在的public方法。 2.参数类型、引用对象尽量使用接口或者抽象类，而不是实现类。 3.抽象层尽量保持稳定，一旦确定即不允许修改。 六大设计原则主要是Java面向对象编程设计的原则，降低项目耦合，分清职责。方便开发和继续维护。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[public、private、protected修饰的方法]]></title>
    <url>%2Fmyblog%2Fpost%2F9d0fb728.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/lgsdaredevil/keyWords.git public：公共的，外部可见方法123public void publicTest()&#123; System.out.print("this is public method!\n"); &#125; private：私有的，外部不可见，只能本类调用的方法1234567private void privateTest()&#123; System.out.print("this is private method!\n"); &#125; public void getPrivate()&#123; this.privateTest(); &#125; protected：被保护的方法，存在继承关系，父类方法被保护，父类可以自己调用，子类也可以调用父类的protected方法，非继承关系不可见Father类： 123456789101112protected void protectedTest()&#123; System.out.print("this is father's protected method!\n"); &#125; private void privateFather()&#123; System.out.print("this is father's private method!\n"); &#125; public void fatherTest()&#123; this.privateFather(); this.protectedTest(); &#125; Child类： 1234public void childTest()&#123; System.out.print("this is child's method\n"); super.protectedTest(); &#125; main方法： 1234567891011public static void main(String[] args)&#123; JavaPublic javaPublic = new JavaPublic(); javaPublic.publicTest(); JavaPrivate javaPrivate = new JavaPrivate(); javaPrivate.getPrivate(); Child child = new Child(); child.childTest(); // 父类对象引用子类不可以调用父类的protected方法 Father father = new Child(); father.fatherTest(); &#125; 输出结果： 总结：public 外部可见private 外部不可见，只能本类调用protected 继承关系中，基类还有protected修饰成员，衍生类可以调用，非继承关系不可见]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder区别]]></title>
    <url>%2Fmyblog%2Fpost%2F88b1c03b.html</url>
    <content type="text"><![CDATA[一、String类1、String类是不可变类，一旦String被创建，包含在这个对象中的字符串序列是不可变的，直至对象被销毁。 String类通过char数组存放字符串的。 12345678910&lt;code class="language-java"&gt;/** 用于字符存储. */ private final char value[]; /** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */ public String() &#123; this.value = "".value; &#125;&lt;/code&gt; 在String的其他方法中，返回的都是new String(); 所以对String进行操作，返回的都是一个新的字符串。 2、字符串常量池 Java运行时会维护一个String Pool（String池），也叫字符串缓冲区。存储运行时产生的各种字符串，并且池中字符串不重复。 3、String对象创建原理 ​ 1）当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个s在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则不在池中添加。 ​ 2）Java中，只要是使用new关键字来创建对象，则一定会（在堆区）创建一个新的对象。 ​ 3）使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，如果有就不会创建，但是绝对不会在堆栈区再去创建该String对象。 ​ 4）使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。最后指向堆内存中的对象。 123456789@Test public void stringTest()&#123; String s1 = "hello world"; String s2 = "hello world"; String s3 = new String("hello world"); System.out.print(s1==s2); System.out.print(s1==s3); System.out.print(s2==s3); &#125; 返回结果是true，false，false。 二、StringBuffer和StringBuilder​ 都继承了AbstractStringBuilder类，实现方法和使用都一样。，唯一区别是，StringBuffer方法加synchronized关键字，线程安全，而StringBuilder是线程非安全的，但是StringBuilder字符串拼接速度比StringBuffer快 ​ StringBuilder相较于StringBuffer有速度的优势，所以多数情况下建议使用StringBuilder类。然而在应用程序要求线程安全的情况下，则必须使用StringBuffer类。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络协议]]></title>
    <url>%2Fmyblog%2Fpost%2F17750952.html</url>
    <content type="text"><![CDATA[七层协定​ 越接近硬件的阶层为底层，越接近应用程序的层为高层。无论接收端还是发送端，每一阶层只认识对方的同一阶层数据。客户端通过应用程序将数据放入第七层，再将第七层数据打包到第六层，依次打包到第一层，然后传送给接收端，接收端主机由第一层开始，依序打开每个包，然后交给对应的阶层处理。 TCP/IP​ TCP/IP 也是使用 OSI 七层协议的观念， 所以同 样具有分层的架构，只是将它简化为四层。 ​ 从图中可以发现，TCP/IP 将应用、表现、会谈三层整合成一个应用层，在 应用层上面可以实作的程序协议有 HTTP, SMTP, DNS 等等。 传送层则没有变，不过依 据传送的可靠性又将封包格式分为连接导向的 TCP 及非连接导向的 UDP 封包格式。网 络层也没有变，主要内容是提供了 IP 封包，并可选择最佳路由来到达目标 IP 地址。数据链结层与物理层则整合成为一个链结层，包括定义硬件讯号、 讯框转位串的编码 等等，因此主要与硬件 (不论是区网还是广域网) 有关。 TCP/IP运作过程 应用程序阶段：打开浏览器，在浏览器上面输入网址，按下 [Enter]。 此时网址与相关数据会被浏览器包成一个数据， 并向下传给 TCP/IP 的应用层； 应用层：由应用层提供的 HTTP 通讯协议，将来自浏览器的数据包起来，并给予一个应用层表头，再向传送层丢去； 传送层：由于 HTTP 为可靠联机，因此将该数据丢入TCP 封包内，并给予 一个 TCP 封包的表头，向网络层丢去； 网络层：将 TCP 包裹包进 IP 封包内，再给予一个 IP 表头 (主要就是来源与目标的 IP)，向链结层丢去； 链结层：如果使用以太网络时，此时 IP 会依据 CSMA/CD 的标准，包裹到 MAC 讯框中，并给予 MAC 表头，再转成位串后， 利用传输媒体传送到远程主机 上。 TCP三次握手​ A：封包发起 当客户端对服务器端联机时，就必须要送出一个要求联机的封包，此时客户端必须随机取用一个大于 1024 以上的端口来做为程序沟通的接口。然后在TCP 的表头当中，必须要带有 SYN 的主动联机(SYN=1)，并且记下发送出联机封包给服务器端的序号 (Sequence number = 10001) 。 B：封包接收与确认封包传送 当服务器接到这个封包，并确定要接收这个封包后，就会制作一个同时带有SYN=1，ACK=1的封包，其中acknowledge的号码要给客户端确认用，所以该数字会比（A步骤）里面的Sequence号码多一号（ack=10001+1=10002），那我们服务器也必须要确认客户端确实可以接收我们的封包才行， 所以也会发送出一个 Sequence (seq=20001) 给客户端，并且开始等待客户端给我们服务器端的回应。 C：回送确认封包 当客户端接收到来自服务器端的aACK数字后（10002）就能够确认之前那个要求封包被正常的接收了，接下来如果客户端也同意与服务器端建立联机时，就会再次发送一个确认封包 (ACK=1) 给服务器，亦即是 acknowledge = 20001+1 = 20002。 D：取得最后的确认 若一切顺利，在服务器端收到带有ACK=1且ack=20002的封包后，就能建立起这次的联机了。 为什么TCP客户端最后还要发送一次确认呢？主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 UDP协议​ UDP和TCP不一样，UDP不提供可靠的传输模式，因为他不是面向连接的一个机制，因为在UDP的传输过程中，接收端在接收到封包后，不会回复响应封包（ACK）给发送端，所以封包并没有像TCP封包有较为严密的检查机制。UDP 可以在 Data 处填入更多的数据了。同时 UDP 比较 适合需要实时反应的一些数据流，例如影像实时传送软件等， 就可以使用这类的封包传送。 TCP连接释放（四次挥手） 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 参考文章： https://blog.csdn.net/qzcsu/article/details/72861891]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】简洁又快速地处理集合——java8 Stream（下）]]></title>
    <url>%2Fmyblog%2Fpost%2F9e7dbf5a.html</url>
    <content type="text"><![CDATA[作者：Howie_Y 主页：www.jianshu.com/u/79638e5f0743 上一篇文章我讲解 Stream 流的基本原理，以及它的基本方法使用，本篇文章我们继续讲解流的其他操作 值得注意的是：学习 Stream 之前必须先学习 lambda 的相关知识。本文也假设读者已经掌握 lambda 的相关知识。 本篇文章主要内容： 一种特化形式的流——数值流 Optional 类 如何构建一个流 collect 方法 并行流相关问题 一. 数值流 前面介绍的如 1int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum); 计算元素总和的方法其中暗含了装箱成本，map(Person::getAge) 方法过后流变成了 Stream类型，而每个 Integer 都要拆箱成一个原始类型再进行 sum 方法求和，这样大大影响了效率。 针对这个问题 Java 8 有良心地引入了数值流 IntStream, DoubleStream, LongStream，这种流中的元素都是原始数据类型，分别是 int，double，long 1. 流与数值流的转换 流转换为数值流 mapToInt(T -&gt; int) : return IntStream mapToDouble(T -&gt; double) : return DoubleStream mapToLong(T -&gt; long) : return LongStream 1IntStream intStream = list.stream().mapToInt(Person::getAge); 当然如果是下面这样便会出错 1LongStream longStream = list.stream().mapToInt(Person::getAge); 因为 getAge 方法返回的是 int 类型（返回的如果是 Integer，一样可以转换为 IntStream） 数值流转换为流 很简单，就一个 boxed 1Stream&lt;Integer&gt; stream = intStream.boxed(); 2. 数值流方法 下面这些方法作用不用多说，看名字就知道： sum() max() min() average() 等… 3. 数值范围 IntStream 与 LongStream 拥有 range 和 rangeClosed 方法用于数值范围处理 IntStream ： rangeClosed(int, int) / range(int, int) LongStream ： rangeClosed(long, long) / range(long, long) 这两个方法的区别在于一个是闭区间，一个是半开半闭区间： rangeClosed(1, 100) ：[1, 100] range(1, 100) ：[1, 100) 我们可以利用 IntStream.rangeClosed(1, 100) 生成 1 到 100 的数值流 123//求 1 到 10 的数值总和：IntStream intStream = IntStream.rangeClosed(1, 10);int sum = intStream.sum(); 二. Optional 类 NullPointerException 可以说是每一个 Java 程序员都非常讨厌看到的一个词，针对这个问题， Java 8 引入了一个新的容器类 Optional，可以代表一个值存在或不存在，这样就不用返回容易出问题的 null。之前文章的代码中就经常出现这个类，也是针对这个问题进行的改进。 Optional 类比较常用的几个方法有： isPresent() ：值存在时返回 true，反之 flase get() ：返回当前值，若值不存在会抛出异常 orElse(T) ：值存在时返回该值，否则返回 T 的值 Optional 类还有三个特化版本 OptionalInt，OptionalLong，OptionalDouble，刚刚讲到的数值流中的 max 方法返回的类型便是这个 Optional 类其中其实还有很多学问，讲解它说不定也要开一篇文章，这里先讲那么多，先知道基本怎么用就可以。 三. 构建流 之前我们得到一个流是通过一个原始数据源转换而来，其实我们还可以直接构建得到流。 1. 值创建流 Stream.of(T…) ： Stream.of(“aa”, “bb”) 生成流 12//生成一个字符串流Stream&lt;String&gt; stream = Stream.of("aaa", "bbb", "ccc"); Stream.empty() : 生成空流 2. 数组创建流 根据参数的数组类型创建对应的流： Arrays.stream(T[ ]) Arrays.stream(int[ ]) Arrays.stream(double[ ]) Arrays.stream(long[ ]) 值得注意的是，还可以规定只取数组的某部分，用到的是Arrays.stream(T[], int, int) 1234//只取索引第 1 到第 2 位的：int[] a = &#123;1, 2, 3, 4&#125;;Arrays.stream(a, 1, 3).forEach(System.out :: println);//打印 2 ，3 3. 文件生成流 1Stream&lt;String&gt; stream = Files.lines(Paths.get("data.txt")); 每个元素是给定文件的其中一行 4. 函数生成流 两个方法： iterate ： 依次对每个新生成的值应用函数 generate ：接受一个函数，生成一个新的值 123456Stream.iterate(0, n -&gt; n + 2)//生成流，首元素为 0，之后依次加 2Stream.generate(Math :: random)//生成流，为 0 到 1 的随机双精度数Stream.generate(() -&gt; 1)//生成流，元素全为 1 四. collect 收集数据 coollect 方法作为终端操作，接受的是一个 Collector 接口参数，能对数据进行一些收集归总操作 1. 收集 最常用的方法，把流中所有元素收集到一个 List, Set 或 Collection 中 toList toSet toCollection toMap 123List newlist = list.stream.collect(toList());//如果 Map 的 Key 重复了，可是会报错的哦Map&lt;Integer, Person&gt; map = list.stream().collect(toMap(Person::getAge, p -&gt; p)); 2. 汇总 （1）counting 用于计算总和： 1long l = list.stream().collect(counting()); 没错，你应该想到了，下面这样也可以： 1long l = list.stream().count(); 推荐第二种 （2）summingInt ，summingLong ，summingDouble summing，没错，也是计算总和，不过这里需要一个函数参数 计算 Person 年龄总和： 1int sum = list.stream().collect(summingInt(Person::getAge)); 当然，这个可以也简化为： 1int sum = list.stream().mapToInt(Person::getAge).sum(); 除了上面两种，其实还可以： 1int sum = list.stream().map(Person::getAge).reduce(Interger::sum).get(); 推荐第二种 由此可见，函数式编程通常提供了多种方式来完成同一种操作 （3）averagingInt，averagingLong，averagingDouble 看名字就知道，求平均数 1Double average = list.stream().collect(averagingInt(Person::getAge)); 当然也可以这样写 1OptionalDouble average = list.stream().mapToInt(Person::getAge).average(); 不过要注意的是，这两种返回的值是不同类型的 （4）summarizingInt，summarizingLong，summarizingDouble 这三个方法比较特殊，比如 summarizingInt 会返回 IntSummaryStatistics 类型 1IntSummaryStatistics l = list.stream().collect(summarizingInt(Person::getAge)); IntSummaryStatistics 包含了计算出来的平均值，总数，总和，最值，可以通过下面这些方法获得相应的数据 12345getAverage() doublegetCount() longgetMax() intgetMin() intgetSum() long 3. 取最值 maxBy，minBy 两个方法，需要一个 Comparator 接口作为参数 1Optional&lt;Person&gt; optional = list.stream().collect(maxBy(comparing(Person::getAge))); 我们也可以直接使用 max 方法获得同样的结果 1Optional&lt;Person&gt; optional = list.stream().max(comparing(Person::getAge)); 4. joining 连接字符串 也是一个比较常用的方法，对流里面的字符串元素进行连接，其底层实现用的是专门用于字符串连接的 StringBuilder 1234String s = list.stream().map(Person::getName).collect(Collectors.joining());//结果：jackmiketomString s = list.stream().map(Person::getName).collect(Collectors.joining(","));//结果：jack,mike,tom joining 还有一个比较特别的重载方法： 12String s = list.stream().map(Person::getName).collect(Collectors.joining(" and ", "Today ", " play games."));//结果：Today jack and mike and tom play games. 即 Today 放开头，play games. 放结尾，and 在中间连接各个字符串 5. groupingBy 分组 groupingBy 用于将数据分组，最终返回一个 Map 类型 1Map&lt;Integer, List&lt;Person&gt;&gt; map = list.stream().collect(groupingBy(Person::getAge)); 例子中我们按照年龄 age 分组，每一个 Person 对象中年龄相同的归为一组 另外可以看出，Person::getAge 决定 Map 的键（Integer 类型），list 类型决定 Map 的值（List类型） 多级分组 groupingBy 可以接受一个第二参数实现多级分组： 1Map&lt;Integer, Map&lt;T, List&lt;Person&gt;&gt;&gt; map = list.stream().collect(groupingBy(Person::getAge, groupingBy(...))); 其中返回的 Map 键为 Integer 类型，值为 Map&lt;t, list 按组收集数据 1Map&lt;Integer, Integer&gt; map = list.stream().collect(groupingBy(Person::getAge, summingInt(Person::getAge))); 该例子中，我们通过年龄进行分组，然后 summingInt(Person::getAge)) 分别计算每一组的年龄总和（Integer），最终返回一个 Map 根据这个方法，我们可以知道，前面我们写的： 1groupingBy(Person::getAge) 其实等同于： 1groupingBy(Person::getAge, toList()) 6. partitioningBy 分区 分区与分组的区别在于，分区是按照 true 和 false 来分的，因此partitioningBy 接受的参数的 lambda 也是 T -&gt; boolean 12345678//根据年龄是否小于等于20来分区Map&lt;Boolean, List&lt;Person&gt;&gt; map = list.stream() .collect(partitioningBy(p -&gt; p.getAge() &lt;= 20));//打印输出&#123; false=[Person&#123;name='mike', age=25&#125;, Person&#123;name='tom', age=30&#125;], true=[Person&#123;name='jack', age=20&#125;]&#125; 同样地 partitioningBy 也可以添加一个收集器作为第二参数，进行类似 groupBy 的多重分区等等操作。 五. 并行 我们通过 list.stream() 将 List 类型转换为流类型，我们还可以通过 list.parallelStream() 转换为并行流。因此你通常可以使用 parallelStream 来代替 stream 方法 并行流就是把内容分成多个数据块，使用不同的线程分别处理每个数据块的流。这也是流的一大特点，要知道，在 Java 7 之前，并行处理数据集合是非常麻烦的，你得自己去将数据分割开，自己去分配线程，必要时还要确保同步避免竞争。 Stream 让程序员能够比较轻易地实现对数据集合的并行处理，但要注意的是，不是所有情况的适合，有些时候并行甚至比顺序进行效率更低，而有时候因为线程安全问题，还可能导致数据的处理错误，这些我会在下一篇文章中讲解。 比方说下面这个例子 1int i = Stream.iterate(1, a -&gt; a + 1).limit(100).parallel().reduce(0, Integer::sum); 我们通过这样一行代码来计算 1 到 100 的所有数的和，我们使用了 parallel 来实现并行。 但实际上是，这样的计算，效率是非常低的，比不使用并行还低！一方面是因为装箱问题，这个前面也提到过，就不再赘述，还有一方面就是 iterate 方法很难把这些数分成多个独立块来并行执行，因此无形之中降低了效率。 流的可分解性 这就说到流的可分解性问题了，使用并行的时候，我们要注意流背后的数据结构是否易于分解。比如众所周知的 ArrayList 和 LinkedList，明显前者在分解方面占优。 我们来看看一些数据源的可分解性情况 数据源可分解性ArrayList极佳LinkedList差IntStream.range极佳Stream.iterate差HashSet好TreeSet好顺序性。 除了可分解性，和刚刚提到的装箱问题，还有一点值得注意的是一些操作本身在并行流上的性能就比顺序流要差，比如：limit，findFirst，因为这两个方法会考虑元素的顺序性，而并行本身就是违背顺序性的，也是因为如此 findAny 一般比 findFirst 的效率要高。 六. 效率 最后再来谈谈效率问题，很多人可能听说过有关 Stream 效率低下的问题。其实，对于一些简单的操作，比如单纯的遍历，查找最值等等，Stream 的性能的确会低于传统的循环或者迭代器实现，甚至会低很多。 但是对于复杂的操作，比如一些复杂的对象归约，Stream 的性能是可以和手动实现的性能匹敌的，在某些情况下使用并行流，效率可能还远超手动实现。好钢用在刀刃上，在适合的场景下使用，才能发挥其最大的用处。 函数式接口的出现主要是为了提高编码开发效率以及增强代码可读性；与此同时，在实际的开发中，并非总是要求非常高的性能，因此 Stream 与 lambda 的出现意义还是非常大的。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>stream</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】简洁又快速地处理集合——java8 Stream（上）]]></title>
    <url>%2Fmyblog%2Fpost%2F26c1d83f.html</url>
    <content type="text"><![CDATA[作者：Howie_Y 主页：www.jianshu.com/u/79638e5f0743 Java 8 发布至今也已经好几年过去，如今 Java 也已经向 11 迈去，但是 Java 8 作出的改变可以说是革命性的，影响足够深远，学习 Java 8 应该是 Java 开发者的必修课。 今天给大家带来 Java 8 Stream 讲解，为什么直接讲这个，是因为只要你学完，立刻就能上手，并能让它在你的代码中大展身手。 值得注意的是：学习 Stream 之前必须先学习 lambda 的相关知识。本文也假设读者已经掌握 lambda 的相关知识。 本篇文章主要内容： 介绍 Stream 以及 Stream 是如何处理集合的 介绍 Stream 与集合的关系与区别 Stream 的基本方法介绍 一. 什么是 Stream Stream 中文称为 “流”，通过将集合转换为这么一种叫做 “流” 的元素序列，通过声明性方式，能够对集合中的每个元素进行一系列并行或串行的流水线操作。 换句话说，你只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理，而你只需要 “坐享其成”。 二. 流操作 整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理。 其中数据源便是原始集合，然后将如 List的集合转换为 Stream类型的流，并对流进行一系列的中间操作，比如过滤保留部分元素、对元素进行排序、类型转换等；最后再进行一个终端操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等等 很重要的一点是，很多流操作本身就会返回一个流，所以多个操作可以直接连接起来，我们来看看一条 Stream 操作的代码： 如果是以前，进行这么一系列操作，你需要做个迭代器或者 foreach 循环，然后遍历，一步步地亲力亲为地去完成这些操作；但是如果使用流，你便可以直接声明式地下指令，流会帮你完成这些操作。 有没有想到什么类似的？是的，就像 SQL 语句一样， select username from user where id = 1，你只要说明：“我需要 id 是 1 （id = 1）的用户（user）的用户名（username ）”，那么就可以得到自己想要的数据，而不需要自己亲自去数据库里面循环遍历查找。 三. 流与集合 什么时候计算 Stream 和集合的其中一个差异在于什么时候进行计算。 一个集合，它会包含当前数据结构中所有的值，你可以随时增删，但是集合里面的元素毫无疑问地都是已经计算好了的。 流则是按需计算，按照使用者的需要计算数据，你可以想象我们通过搜索引擎进行搜索，搜索出来的条目并不是全部呈现出来的，而且先显示最符合的前 10 条或者前 20 条，只有在点击 “下一页” 的时候，才会再输出新的 10 条。 再比方在线观看电影和你硬盘里面的电影，也是差不多的道理。 外部迭代和内部迭代 Stream 和集合的另一个差异在于迭代。 我们可以把集合比作一个工厂的仓库，一开始工厂比较落后，要对货物作什么修改，只能工人亲自走进仓库对货物进行处理，有时候还要将处理后的货物放到一个新的仓库里面。在这个时期，我们需要亲自去做迭代，一个个地找到需要的货物，并进行处理，这叫做外部迭代。 后来工厂发展了起来，配备了流水线作业，只要根据需求设计出相应的流水线，然后工人只要把货物放到流水线上，就可以等着接收成果了，而且流水线还可以根据要求直接把货物输送到相应的仓库。 这就叫做内部迭代，流水线已经帮你把迭代给完成了，你只需要说要干什么就可以了（即设计出合理的流水线）。 Java 8 引入 Stream 很大程度是因为，流的内部迭代可以自动选择一种合适你硬件的数据表示和并行实现；而以往程序员自己进行 foreach 之类的时候，则需要自己去管理并行等问题。 一次性的流 流和迭代器类似，只能迭代一次。 123Stream&lt;String&gt; stream = list.stream().map(Person::getName).sorted().limit(10); List&lt;String&gt; newList = stream.collect(toList());List&lt;String&gt; newList2 = stream.collect(toList()); 上面代码中第三行会报错，因为第二行已经使用过这个流，这个流已经被消费掉了 四. 方法介绍，开始实战 首先我们先创建一个 Person 泛型的 List 1234List&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(new Person("jack", 20));list.add(new Person("mike", 25));list.add(new Person("tom", 30)); Person 类包含年龄和姓名两个成员变量 12private String name;private int age; 1. stream() / parallelStream() 最常用到的方法，将集合转换为流 123List list = new ArrayList();// return Stream&lt;E&gt;list.stream(); 而 parallelStream() 是并行流方法，能够让数据集执行并行操作，后面会更详细地讲解 2. filter(T -&gt; boolean) 保留 boolean 为 true 的元素 123456//保留年龄为 20 的 person 元素list = list.stream() .filter(person -&gt; person.getAge() == 20) .collect(toList());//打印输出 [Person&#123;name='jack', age=20&#125;] collect(toList()) 可以把流转换为 List 类型，这个以后会讲解 3. distinct() 去除重复元素，这个方法是通过类的 equals 方法来判断两个元素是否相等的 如例子中的 Person 类，需要先定义好 equals 方法，不然类似[Person{name=’jack’, age=20}, Person{name=’jack’, age=20}] 这样的情况是不会处理的 4. sorted() / sorted((T, T) -&gt; int) 如果流中的元素的类实现了 Comparable 接口，即有自己的排序规则，那么可以直接调用 sorted() 方法对元素进行排序，如 Stream 反之, 需要调用 sorted((T, T) -&gt; int) 实现 Comparator 接口 1234//根据年龄大小来比较：list = list.stream() .sorted((p1, p2) -&gt; p1.getAge() - p2.getAge()) .collect(toList()); 当然这个可以简化为 123list = list.stream() .sorted(Comparator.comparingInt(Person::getAge)) .collect(toList()); 5. limit(long n) 返回前 n 个元素 1234list = list.stream() .limit(2) .collect(toList());//打印输出 [Person&#123;name='jack', age=20&#125;, Person&#123;name='mike', age=25&#125;] 6. skip(long n) 去除前 n 个元素 1234list = list.stream() .skip(2) .collect(toList());//打印输出 [Person&#123;name='tom', age=30&#125;] tips: 用在 limit(n) 前面时，先去除前 m 个元素再返回剩余元素的前 n 个元素 limit(n) 用在 skip(m) 前面时，先返回前 n 个元素再在剩余的 n 个元素中去除 m 个元素 12345list = list.stream() .limit(2) .skip(1) .collect(toList());//打印输出 [Person&#123;name='mike', age=25&#125;] 7. map(T -&gt; R) 将流中的每一个元素 T 映射为 R（类似类型转换） 12List&lt;String&gt; newlist = list.stream().map(Person::getName).collect(toList()); newlist 里面的元素为 list 中每一个 Person 对象的 name 变量 8. flatMap(T -&gt; Stream**)** 将流中的每一个元素 T 映射为一个流，再把每一个流连接成为一个流 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("aaa bbb ccc");list.add("ddd eee fff");list.add("ggg hhh iii");list = list.stream().map(s -&gt; s.split(" ")).flatMap(Arrays::stream).collect(toList()); 上面例子中，我们的目的是把 List 中每个字符串元素以” “分割开，变成一个新的 List。 首先 map 方法分割每个字符串元素，但此时流的类型为 Stream，因为 split 方法返回的是 String[ ] 类型；所以我们需要使用 flatMap 方法，先使用Arrays::stream将每个 String[ ] 元素变成一个 Stream流，然后 flatMap 会将每一个流连接成为一个流，最终返回我们需要的 Stream 9. anyMatch(T -&gt; boolean) 流中是否有一个元素匹配给定的 T -&gt; boolean 条件 12//是否存在一个 person 对象的 age 等于 20：boolean b = list.stream().anyMatch(person -&gt; person.getAge() == 20); 10. allMatch(T -&gt; boolean) 流中是否所有元素都匹配给定的 T -&gt; boolean 条件 11. noneMatch(T -&gt; boolean) 流中是否没有元素匹配给定的 T -&gt; boolean 条件 12. findAny() 和 findFirst() findAny()：找到其中一个元素 （使用 stream() 时找到的是第一个元素；使用 parallelStream() 并行时找到的是其中一个元素） findFirst()：找到第一个元素 值得注意的是，这两个方法返回的是一个 Optional**对象，它是一个容器类，能代表一个值存在或不存在，这个后面会讲到 13. reduce((T, T) -&gt; T) 和 reduce(T, (T, T) -&gt; T) 用于组合流中的元素，如求和，求积，求最大值等 1234//计算年龄总和：int sum = list.stream().map(Person::getAge).reduce(0, (a, b) -&gt; a + b);//与之相同:int sum = list.stream().map(Person::getAge).reduce(0, Integer::sum); 其中，reduce 第一个参数 0 代表起始值为 0，lambda (a, b) -&gt; a + b 即将两值相加产生一个新值。 同样地： 1234//计算年龄总乘积：int sum = list.stream().map(Person::getAge).reduce(1, (a, b) -&gt; a * b);//当然也可以Optional&lt;Integer&gt; sum = list.stream().map(Person::getAge).reduce(Integer::sum); 即不接受任何起始值，但因为没有初始值，需要考虑结果可能不存在的情况，因此返回的是 Optional 类型。 13. count() 返回流中元素个数，结果为 long 类型 14. collect() 收集方法，我们很常用的是 collect(toList())，当然还有 collect(toSet()) 等，参数是一个收集器接口，这个后面会另外讲。 15. forEach() 返回结果为 void，很明显我们可以通过它来干什么了，比方说： 1234//### 16. unordered()还有这个比较不起眼的方法，//#返回一个等效的无序流，当然如果流本身就是无序的话，那可能就会直接返回其本身//打印各个元素：list.stream().forEach(System.out::println); 再比如说 MyBatis 里面访问数据库的 mapper 方法： 12//向数据库插入新元素：list.stream().forEach(PersonMapper::insertPerson);]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>stream</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机笔记（三）]]></title>
    <url>%2Fmyblog%2Fpost%2Fb8d91ecc.html</url>
    <content type="text"><![CDATA[虚拟机类加载机制类加载时机​ 类从被加载到虚拟机内存开始到卸载内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 ​ 类必须立即初始化情况： 遇到 new、getstatic、putstatic和invokestatic这4条字节码指令时。 使用java.lang.reflect包方法对类进行反射调用时候。 当初始化一个类的时候，欺父类没有被初始化要先初始化其父类。 虚拟机启动时用户需要指定要执行的主类（包括main方法），虚拟机会先初始化这个主类。 如果一个java.lang.reflect.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则先触发其初始化。 类加载过程加载 通过一个类的全限定名获取此类的二进制字节流。 将这个字节流所代表的的静态存储结构转换成方法区的运行时数据结构。 在内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。 验证​ 是连接阶段的第一步，这个阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机的自身安全。 文件格式验证 第一阶段验证字节流是否符合Class文件格式规范，并能被当前版本虚拟机处理。 云数据验证 第二阶段对字节码描述的信息进行语义分析，确保描述信息符合Java语言要求规范。 字节码验证 第三阶段对类的方法体进行校验分析，保证被校验的方法在运行时不会出现危害虚拟机的安全事件。 符号引用验证 对类自身以外（常量池中的各种符号引用）的信息进行匹配校验。 准备​ 正式为变量分配内存并设置初始值的阶段，这些变量使用的内存将在方法区中分配。仅包括类变量（被static修饰）不包括实例变量。赋初值是指数据类型的零值。 解析​ 将常量池中的符号引用替换为直接引用。 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。 直接引用：可以直接指向目标的指针、相对偏移量或能间接的定位到目标的句柄。 初始化执行类中定义的Java程序代码，初始化阶段是执行类构造器（\()）方法的过程。 类加载器启动类加载器、扩展类加载器、应用程序类加载器。 双亲委派模型 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器的父子关系一般是组合关系来复用父加载器的代码。 ​ 工作过程：如果一个类加载器收到类加载请求，首先会把这个请求为派给父类加载器去完成，每一层的类加载器都是这样的，因此所有请求都传给顶层的启动类加载器，只有当父类加载器反馈无法完成加载请求，子类才会尝试自己加载。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机笔记（二）]]></title>
    <url>%2Fmyblog%2Fpost%2Ff5c7bd9e.html</url>
    <content type="text"><![CDATA[判断对象是否存活一、引用计数算法​ 给对象中添加一个引用计数器，每当有一个地方引用他时就给计数器值加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。 ​ 缺点：很难解决对象之间互相循环引用的问题。 二、可达性分析算法​ 以“GC Root”对象为起始点，从此节点向下搜索，搜索所走的路径成为引用链，当一个对象和GC Root之间没有任何引用链的时候，则此对象为不可用对象。 如上图所示，Object1到Object4与GC Root之间存在引用链，所以Object1到Object4的对象是可达对象，而Object5和Object6没有雨GC Root相关的引用链，所以Object5和Object6是不可达对象，是可以回收的对象。 ​ Java中可以被称为GC Root的对象有以下几种： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 三、四种引用类型 强引用：类似于new一个对象的引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：描述的是一些还有用但并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存就会抛出内存溢出异常。 弱引用：描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是当这个对象被收集器收集时会收到一个系统通知。 如果一个对象在可达性分析时没后没有与GC Root相连接的引用链，它将会第一次标记并筛选，筛选条件是该对象是否有必要执行finalize()方法，如果有必要执行finalize()方法，对象只要重新与引用链上的任何一个对象建立关联即可，拿在第二次标记时将他移除“即将回收”集合。任何对象的finalize()方法只会被调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。 垃圾收集算法一、标记—清除算法​ 首先标记出所有要回收的对象，在标记完成后统一回收被标记的对象。 ​ 缺点：1、效率问题，标记和清除两个过程的效率都不高。 2、空间问题，标记清除会产生大量不连续的内存碎片，空间碎片太多会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得进行另一次垃圾收集动作。 二、复制算法​ 将内存安容量分为大小相等的两块，每次只使用其中一块，当着一块内存用完后，将存活的对象复制到另一块上面，再把已使用的内存清理掉。 ​ 一般虚拟机是将内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用？Eden和其中一块Survivor，回收时，将Eden和Survivor还存后的对象复制到Survivor空间，再清理掉刚才用到的Survivor和Eden空间。当Survivor内存不足时会用到其他内存（老年代）进行分配担保。 ​ 缺点：在对象存活率较高时就要进行较多的复制操作，效率会变低，老年代一般不能直接选用这种做法。 三、标记—整理算法​ 标记过程与标记—清除算法相同，然后让所有存活的对象都像一端移动，然后直接清理掉端边界以外的内存。适用于老年代整理。 四、分代收集算法​ 一般根据对象存活周期将对象划分为几块。Java堆分为新生代和老年代。新生代一般采用复制算法，而老年代对象存活较高，没有额外空间对它进行分配担保，就必须使用标记—清除或标记—整理算法。 垃圾收集器一、Serial收集器​ 是虚拟机在client模式下默认的新生代收集器，是单线程收集器，必须停掉其他所有工作线程，知道他收集结束。 二、ParNew收集器​ 时Serial收集器的多线程版本。是许多运行在server模式下的虚拟机的首选的新生代收集器。除了Serial收集器外，只有它能与CMS收集器配合工作。 三、Parallel Scavenge收集器​ 并行多线程的新生代收集器。CMS等收集器的特点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制吞吐量。吞吐量是指CPU用于运行用户代码的时间与CPU总消耗的时间的比值 四、Serial Old收集器​ 是Serial收集器的老年代版本，单线程收集器。主要是给client模式下的虚拟机使用。在server模式下：一是可以与Parallel Scavenge收集器配合使用。另一方面是作为CMS收集器的后备方案。 五、Parallel Old收集器​ 是Parallel Scavenge收集器的老年代版本，使用多线程和标记—整理算法。 六、CMS收集器​ 是一种以获取最短回收时间为目标的收集器。基于标记—清除算法实现。运作过程： 初始标记 并发标记 重新标记 并发清除 其中初始标记和重新标记需要“stop the world”，并发标记和并发清除是和用户线程一起进行的。 缺点：1、对CPU资源敏感，因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 ​ 2、收集器无法处理浮动垃圾。 ​ 3.采用标记—清除算法会产生大量空间碎片。 七、G1收集器​ 面向服务端应用的垃圾收集器。优点如下： 并行并发 分代收集 空间整合 可预测停顿 它将整个Java堆分为多个大小相等的独立区域，保留新生代和老年代概念，但他们不是物理隔离，都是一部分Region的集合。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值大的Region。 G1的操作步骤： 初始标记 并发标记 最终标记 筛选回收 内存分配与回收策略一、对象优先在Eden分配二、大对象直接进入老年代​ 需要大量连续的内存空间的Java对象，最典型就是很长的字符串以及数组。 三、长期存活的对象进入老年代​ 虚拟机给每一个对象定义年龄计数器，在Eden代出生并经过一次Minor GC仍存后，并能被Survivor接收，被移到Survivor空间中，年龄加一。在Survivor中每熬过一次GC，年龄就加一。当年龄到一定长度后就进入老年代。 四、动态对象年龄判断​ 如果在Survivor中的相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于改年龄的对象就会进入老年代。 五、空间分配担保​ 在Minor GC前虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么Minor GC可以确保安全。否则虚拟机会查看HandelPromotionFailure设置的值是否允许担保失败，如果是，则在检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行一次Minor GC。否则进行一次Full GC]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机笔记（一）]]></title>
    <url>%2Fmyblog%2Fpost%2Fc5d15146.html</url>
    <content type="text"><![CDATA[JDK和JRE区别​ 1、一般把Java程序设计语言，java虚拟机，java API类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境。 ​ 2、Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。 Java虚拟机内存区域一、程序计数器​ 可以看做当前线程所执行的字节码的行号指示器。为线程私有的内存。是在Java虚拟机内存区域唯一一个不会内存溢出的区域。 二、Java虚拟机栈​ Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链栈、方法出口等信息。Java虚拟机栈也是线程私有，生命周期和线程相同。 ​ Java虚拟机栈中的局部变量表：存放编译期可知的各种基本数据类型、引用类型（reference）和runAddress类型。局部变量表所需要的内存空间在编译期间完成内存分配，在方法运行期间不会改变局部变量表的大小。 ​ 异常： 1）StackOverflowError：线程请求的栈的深度大于虚拟机所允许的深度。 2）OutOfMemoryError：扩展时无法申请到足够的内存。 三、本地方法栈​ 与Java虚拟机栈类似，线程私有，会抛出StackOverflowError和OutOfMemoryError异常。 ​ Java虚拟机栈区别是本地方法栈为虚拟机使用的Native方法服务，Java虚拟机栈为虚拟机执行Java方法服务。 四、Java堆​ 存放对象实例，被所有线程共享，虚拟机启动时创建。Java堆又称GC堆，垃圾收集器管理的主要区域。 ​ Java堆可以细分为：新生代和老年代。也可以分为Eden空间、From Survivor空间、To Survivor空间等。 如果在堆中没有内存完成实例分配，并且也无法再扩展，会抛出OutOfMemoryError异常 五、方法区​ 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是线程共享的区域。 ​ 与java堆一样不需要连续的内存和可以选择的固定大小并且可以扩展。不同点是可以选择不实现垃圾收集，这个区域主要的内存回收目标是针对常量池的回收和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 六、运行时常量池​ 是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。具备动态特性，运行时也能将新的常量存放入池。同样在无法申请内存时会抛出OutOfMemoryError异常。 七、直接内存​ 不是虚拟机运行数据区的一部分。NIO类可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。也会抛OutOfMemoryErrory异常]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot使用@Async异步任务]]></title>
    <url>%2Fmyblog%2Fpost%2F87c0e04a.html</url>
    <content type="text"><![CDATA[github项目地址：https://github.com/lgsdaredevil/asyncTest 开启异步任务在应用主类中添加@EnableAsync注解 写异步任务方法12345678910111213@Async public Future&lt;String&gt; ansync(String name)&#123; try &#123; Thread.sleep(10000); logger.info("这里是异步方法"); logger.info("传过来的名字是：" + name); name = "修改的名字"; logger.info("修改后的名字是：" + name); return new AsyncResult&lt;&gt;("name: " + name); &#125;catch (Exception e)&#123; return new AsyncResult&lt;&gt;("异常"); &#125; &#125; 调用异步方法 1、用Future获取返回值12345678910111213141516public String requestAnsync(String name)&#123; try &#123; Long start = System.currentTimeMillis(); Future&lt;String&gt; result = ansync(name); if (result.isDone())&#123; name = result.get(); logger.info("异步方法结束，名字改为：" + name); &#125; Long end = System.currentTimeMillis(); logger.info("耗时：" + (int)(end-start)); return "hello " + name; &#125;catch (Exception e)&#123; logger.error("异常"); return "异常"; &#125; &#125; 返回值，若想获取到返回值，应该轮询方法获取，否则若果没有isDone则不会走下面的方法，或者可以使用CompletableFuture：12342018-07-17 11:31:55.390 INFO 5232 --- [nio-8080-exec-6] c.e.async.service.AsyncTestService : 耗时：02018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 这里是异步方法2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 传过来的名字是：ling2018-07-17 11:32:05.394 INFO 5232 --- [cTaskExecutor-3] com.example.async.service.AsyncTest : 修改后的名字是：修改的名字 如果使用future.get()方法会阻塞线程直到拿到结果。 2、不使用future.get()方法，异步方法不使用Future返回1234567891011@Asyncpublic void noReturnAsync(String name)&#123; try &#123; Thread.sleep(10000); logger.info("这里是异步方法"); logger.info("传过来的名字是：" + name); name = "修改的名字"; logger.info("修改后的名字是：" + name); &#125;catch (Exception e)&#123; &#125;&#125; 调用异步的方法1234567public String noReturn(String name)&#123; Long start = System.currentTimeMillis(); asyncTest.noReturnAsync(name); Long end = System.currentTimeMillis(); logger.info("耗时：" + (int)(end-start)); return "hello " + name; &#125; 注意的地方：如果异步方法变成阻塞的同步方法，可能原因是异步方法和普通的调用方法在同一个类中，解决方法是将异步方法单独放到一个类中。产生原因：spring对@Transactional注解时也有类似问题，spring扫描时具有@Transactional注解方法的类时，是生成一个代理类，由代理类去开启关闭事务，而在同一个类中，方法调用是在类体内执行的，spring无法截获这个方法调用。具体参见：Spring Boot使用@Async实现异步调用]]></content>
      <categories>
        <category>技术文章项目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring boot</tag>
        <tag>Async</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署hexo博客到github]]></title>
    <url>%2Fmyblog%2Fpost%2F215fb59.html</url>
    <content type="text"><![CDATA[部署hexo博客到github准备工具&nbsp;&nbsp;&nbsp;&nbsp;Node.js&nbsp;&nbsp;&nbsp;&nbsp;Git&nbsp;&nbsp;&nbsp;&nbsp;GitHub Hexo安装在新目录下输入命令：npm install -g hexo-cli 创建博客文件夹博客目录下输入命令：hexo init 安装依赖包npm install 修改配置文件修改_config.yml文件 url: http://github.com/ root: /newblog permalink: :year/:month/:day/:title/ permalink_defaults:root为文件目录的跟目录 deploy: # 部署相关配置 type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 博客仓库地址 repository后地址为github的项目地址 生成文件hexo g 或者 hexo generate 启动服务hexo s 或 hexo server浏览器输入 http://localhost:4000/(root的目录)查看 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 注意如果发布时候报错： ERROR Deployer not found: Git输入命令：npm install hexo-deployer-git –save，重新发布即可]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>部署博客</tag>
      </tags>
  </entry>
</search>
